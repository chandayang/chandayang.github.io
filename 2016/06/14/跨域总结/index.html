<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>跨域总结 | chandayang&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="javascript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略指定：JavaScript只能访问与包含它的文档在同一域下的内容。所谓同源是指，域名(host)，协议(protocol)，端口(port)相同。
URL     说明  是否跨域http://www.abc.com/a.jshttp://www.abc.com/b.js">
<meta property="og:type" content="article">
<meta property="og:title" content="跨域总结">
<meta property="og:url" content="http://yoursite.com/2016/06/14/跨域总结/index.html">
<meta property="og:site_name" content="chandayang's blog">
<meta property="og:description" content="javascript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略指定：JavaScript只能访问与包含它的文档在同一域下的内容。所谓同源是指，域名(host)，协议(protocol)，端口(port)相同。
URL     说明  是否跨域http://www.abc.com/a.jshttp://www.abc.com/b.js">
<meta property="og:updated_time" content="2016-10-04T06:09:23.082Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跨域总结">
<meta name="twitter:description" content="javascript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略指定：JavaScript只能访问与包含它的文档在同一域下的内容。所谓同源是指，域名(host)，协议(protocol)，端口(port)相同。
URL     说明  是否跨域http://www.abc.com/a.jshttp://www.abc.com/b.js">
  
    <link rel="alternative" href="/atom.xml" title="chandayang&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">chandayang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">前端程序媛一枚</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						<li>友情链接</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">chandayang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">chandayang</h1>
			</hgroup>
			
			<p class="header-subtitle">前端程序媛一枚</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-跨域总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/14/跨域总结/" class="article-date">
  	<time datetime="2016-06-14T05:53:34.000Z" itemprop="datePublished">2016-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      跨域总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javascript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略指定：JavaScript只能访问与包含它的文档在同一域下的内容。所谓同源是指，域名(host)，协议(protocol)，端口(port)相同。</p>
<p>URL     说明  是否跨域<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="http://www.abc.com/b.js" target="_blank" rel="external">http://www.abc.com/b.js</a>     同一域名下   否<br><a href="http://www.abc.com/test/a.js" target="_blank" rel="external">http://www.abc.com/test/a.js</a><br><a href="http://www.abc.com/lib/b.js" target="_blank" rel="external">http://www.abc.com/lib/b.js</a>     同一域名下不同文件夹  否<br><a href="http://www.abc.com:80/a.js" target="_blank" rel="external">http://www.abc.com:80/a.js</a><br><a href="http://www.abc.com/b.js" target="_blank" rel="external">http://www.abc.com/b.js</a>     同一域名，不同端口号  是<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="https://www.abc.com/b.js" target="_blank" rel="external">https://www.abc.com/b.js</a>    同一域名，不同协议(http和https)   是<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="http://127.0.0.1/b.js" target="_blank" rel="external">http://127.0.0.1/b.js</a>   域名与域名对应IP   是<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="http://abc.com/b.js" target="_blank" rel="external">http://abc.com/b.js</a><br><a href="http://www.test.com/b.js" target="_blank" rel="external">http://www.test.com/b.js</a>    不同域名(host)  是</p>
<h1 id="一-ajax设置Access-Control-Allow-Origin实现跨域访问"><a href="#一-ajax设置Access-Control-Allow-Origin实现跨域访问" class="headerlink" title="一.ajax设置Access-Control-Allow-Origin实现跨域访问"></a>一.ajax设置Access-Control-Allow-Origin实现跨域访问</h1><p>通过XHR实现Ajax通信的一个主要限制，来源与跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。</p>
<p>CORS(Cross-Origin Resource Sharing,跨源资源共享)是W3C的一个标准，定义了在必须访问跨资源时，浏览器与服务器应该如何沟通。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。其背后的基本思想是：就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>对于简单的get或post发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息(协议、域名和端口号)，以便服务器根据这个头部信息来决定是否给予响应。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息(origin头)，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>例子：</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
      &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;cors_post&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function createXhr(){  
            if(typeof XMLHttpRequest){  
                return new XMLHttpRequest();  
            }else if(typeof ActiveXObject){  
                return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  
            }  
        }  
        var xhr=createXhr();  
        var data={  
            name:&quot;liujie&quot;,  
            age:&quot;23&quot;  
        };  
        xhr.onreadystatechange=function(){  
            if(xhr.readyState==4){  
                if(xhr.status==200){  
                    //console.log(xhr.responseText);  
                    document.getElementById(&quot;box&quot;).innerHTML=data.name+&apos;---&apos;+data.age;  
                }  
            }  
        }  
        xhr.open(&quot;post&quot;,&quot;http://www.abc.com/21code/cors/post.php&quot;,true);  
        xhr.send(data);  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>请求页面post.php:</p>
<pre><code>&lt;?php  
header(&apos;content-type:application:json;charset=utf8&apos;);  
// 指定允许其他域名访问  
//header(&apos;Access-Control-Allow-Origin:http://www.example.com&apos;);  
header(&apos;Access-Control-Allow-Origin:*&apos;);  
// 响应类型  
header(&apos;Access-Control-Allow-Methods:POST&apos;);  
$res= array(  
    &apos;name&apos; =&gt; isset($_POST[&apos;name&apos;])? $_POST[&apos;name&apos;] : &apos;&apos;,  
    &apos;gender&apos; =&gt; isset($_POST[&apos;gender&apos;])? $_POST[&apos;gender&apos;] : &apos;&apos;  
);  
echo json_encode($res);  
 ?&gt; 
&lt;img src=&quot;http://img.blog.csdn.net/20160809155156139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; /&gt;  
</code></pre><p>通过<a href="http://www.example.com访问这个页面，Origin:http://www.example.com" target="_blank" rel="external">http://www.example.com访问这个页面，Origin:http://www.example.com</a></p>
<p>如果服务器认为这个请求可以接收，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发”*”）。</p>
<p>比如：Access-Control-Allow-Origin：<a href="http://www.example.com" target="_blank" rel="external">http://www.example.com</a></p>
<p>如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。<br>cors基本流程：<br>1.浏览器对于AJAX请求会自动在头信息之中，添加一个Origin字段，该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>2.如果Origin指定的域名在许可范围内，服务器返回的响应，并在响应头的Access-Control-Allow-Origin头部中会发相同的源信息。<br>与CORS请求相关的字段：</p>
<p>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（3）Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（4）Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<br>（5）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true时，Cookie就会包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（6）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。例如：getResponseHeader(‘FooBar’)可以返回FooBar字段的值。<br>withCredentials 属性<br>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<pre><code>Access-Control-Allow-Credentials: true  
</code></pre><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<pre><code>var xhr = new XMLHttpRequest();  
xhr.withCredentials = true;  
</code></pre><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。<br>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<pre><code>xhr.withCredentials = false;  
</code></pre><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。<br>与jsonp的区别：</p>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h1 id="二、图像Ping"><a href="#二、图像Ping" class="headerlink" title="二、图像Ping"></a>二、图像Ping</h1><p>使用img标签，我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。</p>
<p>动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。来看下面的例子。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;Image Ping Example&lt;/title&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;script&gt;  
        var img = new Image();  
        img.onload = img.onerror = function(){  
            alert(&quot;Done!&quot;);  
        };  
        img.src = &quot;http://www.example.com/ajax?name=test&quot;;  
    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>这里创建了一个Image的实例，然后将onload和onerror事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置src属性那一刻开始，而这个例子在请求中发送了一个name参数。</p>
<p>图像Ping最常用于跟踪用户点页面或动态广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。因此，图像Ping只能用于浏览器与服务器间的单向通信。</p>
<h1 id="三、jsonp实现跨域"><a href="#三、jsonp实现跨域" class="headerlink" title="三、jsonp实现跨域"></a>三、jsonp实现跨域</h1><p>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里</p>
<p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>
<p>首先在客户端注册一个callback, 然后把callback的名字传给服务器。此时，服务器先生成 json 数据。然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的参数 jsonp.最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）</p>
<p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
<p>jsonp允许在服务器端集成Script 标签返回至客户端，通过javascript回调函数的形式实现跨域访问。它可以绕过同源策略的方法，即通过使用JSON与script标签相结合的方法，从服务器直接返回可执行的javascript函数调用或者javascript对象。</p>
<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
<p>1.在<a href="http://example.com/jsonp/目录下有个remote.js文件代码如下：" target="_blank" rel="external">http://example.com/jsonp/目录下有个remote.js文件代码如下：</a></p>
<pre><code>alert(&quot;我是远程服务器上的文件&quot;);  
</code></pre><p>在<a href="http://www.example.com/jsonp/目录下有个jsonp.html页面代码如下：" target="_blank" rel="external">http://www.example.com/jsonp/目录下有个jsonp.html页面代码如下：</a></p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;jsonp01&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://example.com/jsonp/remote.js&quot;&gt;&lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>访问jsonp.html页面将会弹出一个提示窗体，显示跨域调用成功。</p>
<p>2.在jsonp02.html页面定义一个函数，然后在远程remote.js中传入数据进行调用</p>
<p>jsonp02.html页面代码如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;jsonp02&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    //现在我们在jsonp02.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。  
     var localHandler = function(data){  
        alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result);  
    };  
    &lt;/script&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://example.com/jsonp/remote.js&quot;&gt;&lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>remote.js文件代码如下：</p>
<pre><code>localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});  
</code></pre><p>访问jsonp.html页面,成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。</p>
<p>3、动态生成script标签</p>
<p>jsonp03.html页面的代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;jsonp03&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
     // 得到学生信息查询结果后的回调函数  
    var flightHandler = function(data){  
        alert(&apos;你查询的学生信息结果是：姓名:&apos; + data.name+&apos;--&apos;+ &apos;年龄:&apos; + data.age);  
    };  
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）  
    var url = &quot;http://example.com/jsonp/remote.js?num=001&amp;callback=flightHandler&quot;;  
    // 创建script标签，设置其属性  
    var script = document.createElement(&apos;script&apos;);  
    script.src=url;  
    // 把script标签加入head，此时调用开始  
    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>remote.js文件代码如下：</p>
<pre><code>flightHandler({  
    &quot;num&quot;: &quot;001&quot;,  
    &quot;name&quot;: &quot;lisi&quot;,  
    &quot;age&quot;: 25  
});  
</code></pre><p>调用的url中传递了一个num参数，告诉服务器我要查的是001的学生信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。我们看到，传递给flightHandler函数的是一个json，它描述了学生的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！<br>jQuery对jsonp的实现</p>
<p>原理是一样的，只不过我们不需要手动的插入script标签以及定义回掉函数。jQuery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。</p>
<p>jquery对jsonp的支持：<br>两种方式：getJSON()方法和ajax指定返回jsonp类型<br>使用getJSON()方法时，必须指定callback=?，表示使用使用jsonp的方式来发起请求</p>
<p>$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<p>getJSON()方法：Demo</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;jsonp&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;input type=&quot;button&quot; value=&quot;jsonp跨域&quot; onclick=&quot;testJsonp()&quot;&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    function testJsonp(){  
        $.getJSON(&apos;http://b.test.com/mywork/kuayu/jsonp/jsopn.php?callback=?&apos;,  
            function(data){  
            console.log(data);  
        })  
    }  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>jsonp.php</p>
<pre><code>&lt;?php  
$jsonp = $_REQUEST[&quot;callback&quot;];  
$str = &apos;{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:23}&apos;;  
$str = $jsonp . &quot;(&quot; .$str.&quot;)&quot;;  
echo $str;  
?&gt;  
</code></pre><p>ajax指定返回jsonp类型：Demo</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;jsonp&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;input type=&quot;button&quot; value=&quot;jsonp跨域&quot; onclick=&quot;testJsonp()&quot;&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
/*  
这里jQuery将自动把URL里的回调函数，例如&quot;url?callback=?&quot;中的后一个&quot;?&quot;替换为正确的函数名，以执行回调函数  
 */  
    function testJsonp(){  
        $.ajax(&apos;http://b.test.com/mywork/kuayu/jsonp/jsopn.php?callback=?&apos;,  
            {dataType:&apos;jsonp&apos;,  
        }).done(function(data){  
            console.log(data);  
        });  
    }  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>$.ajax()跨域原理分析<br>由于javascript的安全限制“同源策略”，所以我们无法使用XMLHttpRequest直接请求别的域名下的资源。不过拥有src属性和href属性的<code>&lt;script&gt;\&lt;img&gt;\&lt;iframe&gt;</code>和<code>&lt;link&gt;\&lt;a&gt;</code>标签不受同源策略影响。$.ajax()正是应用了动态创建<code>&lt;script&gt;</code>的方式来实现（即：生成<code>&lt;script&gt;</code>标签，<code>src</code>引入脚本，然后执行，最后移除<code>&lt;script&gt;</code>标签）。</p>
<h1 id="四、通过修改document-domain来跨子域"><a href="#四、通过修改document-domain来跨子域" class="headerlink" title="四、通过修改document.domain来跨子域"></a>四、通过修改document.domain来跨子域</h1><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域</p>
<p>主域相同的使用document.domain</p>
<p>假设有一个页面，它的地址是<a href="http://www.example.com/abc.html，在这个页面里面有一个iframe，它的src是http://example.com/ab.html" target="_blank" rel="external">http://www.example.com/abc.html，在这个页面里面有一个iframe，它的src是http://example.com/ab.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西。</p>
<p>这时在页面 <a href="http://example.com/ab.html" target="_blank" rel="external">http://example.com/ab.html</a> 和<a href="http://www.example.com/abc.html中设置相同的document.domain，这样我们就可以通过js访问到iframe中的各种属性和对象了。" target="_blank" rel="external">http://www.example.com/abc.html中设置相同的document.domain，这样我们就可以通过js访问到iframe中的各种属性和对象了。</a></p>
<p><a href="http://www.example.com/abc.html页面代码：" target="_blank" rel="external">http://www.example.com/abc.html页面代码：</a></p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;通过修改document.domain来跨子域&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;iframe src=&quot;http://example.com/ab.html&quot; id=&quot;iframe&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    document.domain=&quot;example.com&quot;;//设置成主域  
    function test(){  
        var iframe=document.getElementById(&quot;iframe&quot;);  
        var win=iframe.contentWindow;  
        var doc=win.document;  
        var name=win.name;  
        alert(win);  
        alert(doc);  
       alert(name);  
    }  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p><a href="http://example.com/ab.html页面代码：" target="_blank" rel="external">http://example.com/ab.html页面代码：</a></p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;通过修改document.domain来跨子域&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    document.domain=&quot;example.com&quot;;//设置成主域  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="五、使用window-name来进行跨域"><a href="#五、使用window-name来进行跨域" class="headerlink" title="五、使用window.name来进行跨域"></a>五、使用window.name来进行跨域</h1><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>
<pre><code>http://www.example.com/mywork/kuayu/windowname/aaa.html页面代码：  

&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;使用window.name来进行跨域&lt;/title&gt;  
        &lt;script type=&quot;text/javascript&quot;&gt;  
         function getData(){//iframe载入data.html页面后会执行此函数  
        var iframe=document.getElementById(&quot;iframe&quot;);  
        iframe.onload=function(){//这个时候aaa.html与iframe已经是处于同一源了，可以互相访问  
            var data=iframe.contentWindow.name;//获取iframe里的window.name，也就是data.html页面给它设置的数据  
            alert(data);//成功获取到了data.html里的数据  
        };  
        iframe.src=&quot;http://www.example.com/mywork/kuayu/windowname/a.html&quot;;//这里的a.html为随便的一个页面，只要与aaa.html同源就行，目的是让aaa.html能访问到iframe里的东西，设置成about:blank也行  
    }  
    &lt;/script&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;iframe style=&quot;display:none;&quot; src=&quot;http://example.com/mywork/kuayu/windowname/data.html&quot; id=&quot;iframe&quot; onload=&quot;getData()&quot;&gt;&lt;/iframe&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  

http://example.com/mywork/kuayu/windowname/data.html页面代码：  

&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;使用window.name来进行跨域&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    window.name=&quot;我是页面aaa.html想要的数据&quot;;  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>整个跨域的流程是这样的：<br>先在<a href="http://example.com/mywork/kuayu/windowname/data.html中通过一些操作将数据存入window.name中了" target="_blank" rel="external">http://example.com/mywork/kuayu/windowname/data.html中通过一些操作将数据存入window.name中了</a><br>而<a href="http://www.example.com/mywork/kuayu/windowname/aaa.html想要获取到window.name的值就需要依靠iframe作为中间代理，首先把iframe的src设置成http://example.com/mywork/kuayu/windowname/data.html，这样就相当于要获取iframe的window.name，而要想获取到iframe中的window.name，就需要把iframe的src设置成当前域的一个页面地址&quot;http://www.example.com/mywork/kuayu/windowname/aa.html&quot;或者设置成about:blank也行，不然根据前面讲的同源策略，window.name.html是不能访问到iframe里的window.name属性的。" target="_blank" rel="external">http://www.example.com/mywork/kuayu/windowname/aaa.html想要获取到window.name的值就需要依靠iframe作为中间代理，首先把iframe的src设置成http://example.com/mywork/kuayu/windowname/data.html，这样就相当于要获取iframe的window.name，而要想获取到iframe中的window.name，就需要把iframe的src设置成当前域的一个页面地址&quot;http://www.example.com/mywork/kuayu/windowname/aa.html&quot;或者设置成about:blank也行，不然根据前面讲的同源策略，window.name.html是不能访问到iframe里的window.name属性的。</a> </p>
<h1 id="六-跨文档消息传递"><a href="#六-跨文档消息传递" class="headerlink" title="六 跨文档消息传递"></a>六 跨文档消息传递</h1><p>跨文档消息传送(cross-document messaging)，简称XDM，指的是在来自不同域的页面间传递消息。<br>这个例子就是位于www.example.com域中的页面postmessage.html与位于一个内嵌框架中的www.abc.com域中的页面postmessage2.html通信。</p>
<p>XDM的核心是postMessage()方法，利用这个方法向另外一个地方传递数据。这里另外一个地方指的是包含在当前页面中的<code>&lt;iframe&gt;</code>元素，或者由当前页面弹出的窗口。 postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。如果传给postMessage()方法的第二个参数是”*”，则表示可以把消息发送给来自任何域的文档。</p>
<pre><code>接收到跨文档消息传送的消息时，会触发window对象的message事件，这个事件是以异步形式触发的
要想接收从其他窗口发过来的消息，必须对窗口对象的message事件进行监听

传给onmessage处理程序的事件对象包含以下三个方面的重要信息：
data:作为postMessage()方法第一个参数传入的字符串数据，可以通过message事件的data属性获取消息的内容
origin:发送消息的文档所在的域，可以通过message事件的origin属性获取消息的发送源
source:发送消息的文档的window对象的代理，可以通过message事件的source属性可以获取消息发送源的窗口对象
</code></pre><p>Demo</p>
<p>postmessage.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;UTF-8&quot;&gt;  
    &lt;title&gt;跨文档消息传递&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;  
    &lt;div&gt;  
        &lt;input type=&quot;text&quot; size=&quot;40&quot; id=&quot;msg&quot; placeholder=&quot;请输入内容&quot;&gt;  
        &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;Send to iframe&quot;&gt;  
    &lt;/div&gt;  
    &lt;iframe id=&quot;inner&quot; width=&quot;450&quot; height=&quot;300&quot; src=&quot;http://www.abc.com/HTML5/postMessage/postmessage2.html&quot;&gt;&lt;/iframe&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;../EventUtil.js&quot;&gt;&lt;/script&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    EventUtil.addHandler(window,&apos;message&apos;,function(event){  
        var content=document.getElementById(&quot;content&quot;);  
        content.innerHTML=&quot;iframe said:&quot;+event.data;  
        //event.source.postMessage(&quot;1页面收到消息&quot;,&quot;http://www.abc.com&quot;);  
    });  
    EventUtil.addHandler(document.getElementById(&quot;btn&quot;),&quot;click&quot;,function(event){  
        //msg中存放的是要发送给另一个页面的消息  
        var msg=document.getElementById(&quot;msg&quot;).value;  
        innerWindow=document.getElementById(&quot;inner&quot;).contentWindow;  

        if(innerWindow.postMessage){  
            //*表示可以把消息发送给来自任何域的文档  
            innerWindow.postMessage(msg,&quot;http://www.abc.com/HTML5/postMessage/postmessage2.html&quot;);  
        }else{  
            alert(&quot;Your browser doesn&apos;t support Cross Document Messaging.&quot;);  
        }  
    });  
    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>postmessage2.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;UTF-8&quot;&gt;  
    &lt;title&gt;跨文档消息传递&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;  
&lt;div&gt;  
    &lt;input type=&quot;text&quot; id=&quot;msg&quot; size=&quot;40&quot; placeholder=&quot;请输入内容&quot;&gt;  
    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;Send to parent&quot;&gt;  
&lt;/div&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;../EventUtil.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
EventUtil.addHandler(window,&apos;message&apos;,function(event){  
    var content=document.getElementById(&quot;content&quot;);  
    content.innerHTML=&quot;parent said:&quot;+event.data;  
    //event.source.postMessage(&quot;2页面收到消息&quot;,&quot;http://www.example.com&quot;);  
});  
EventUtil.addHandler(document.getElementById(&quot;btn&quot;),&apos;click&apos;,function(event){  
    var msg=document.getElementById(&quot;msg&quot;).value;  
    /*跨文档消息传送的核心是postMessage()方法  
    使用window对象的postMessage()方法向其他窗口发送消息  
    这个方法接收两个参数：第一个参数为所发送的消息文本；第二个参数为接收消息的对象窗口的URL地址  
    可以在URL地址字符串中使用通配符&quot;*&quot;指定全部地址，但是建议使用准确的URL地址  
    */  
   //console.log(parent);// Window  
    if(parent.postMessage){  
        parent.postMessage(msg,&quot;http://www.example.com/HTML5/postMessage/postmessage.html&quot;);/*使用通配符&quot;*&quot;指定全部地址*/  
    }else{  
        alert(&quot;Your browser doesn&apos;t support Cross Document Messaging.&quot;);  
    }  
});  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>注： EventUtil是封装好的一个js文件，里面定义了给元素绑定事件的一些函数。   </p>
<h1 id="七-Comet"><a href="#七-Comet" class="headerlink" title="七. Comet"></a>七. Comet</h1><p>Ajax是一种页面向服务器请求数据的技术，Comet是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时的被推送到页面上，非常适合处理体育比赛和股票报价。</p>
<p>有两种实现Comet的方式：长轮询和流。长轮询是传统轮询（即短轮询）的一个翻版，即浏览器定时向服务器发送请求，看看有没有数据更新。</p>
<p>短轮询：浏览器定时向服务器发送请求，看看有没有数据更新</p>
<p>短轮询是一种从服务器拉取数据的工作模式。设置一个定时器，定时询问服务器是否有信息，每次建立连接传输数据之后，链接会关闭</p>
<p>短轮询模式：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>
<p>长轮询把传统轮询颠倒了一下，页面发送一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。这个过程在页面打开期间一直不断持续。</p>
<p>长轮询：页面发送一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。</p>
<p>长轮询模式：建立连接——（保持连接直到有数据可发送）…数据传输——关闭连接(随即又向服务器建立一个连接)</p>
<p>长轮询与短轮询的不同：主要在于client和server采取的关闭策略不同。短轮询在建立连接以后只进行一次数据传输就关闭连接，而长轮询在建立连接以后会进行多次数据数据传输直至关闭连接。</p>
<p>无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现，你要做的就是决定什么时候发送请求。</p>
<p>HTTP流</p>
<p>第二种流行的Comet方式是HTTP流。流不同于上述的两种轮询，它在页面的整个生命周期中只使用一个HTTP连接。具体来说就是浏览器向服务器发送一个请求，然后服务器保持连接打开，然后周期性的向浏览器发送数据。下面这段PHP脚本就是采用流实现的服务器中的常见方式：</p>
<p>streaming.php:</p>
<pre><code>&lt;?php  
$i=0;  
while(true){  
echo &quot;Number is $i&quot;;//输出一些数据，然后立即刷新输出缓存  
flush();  
sleep(10);//等几秒  
$i++;  
}  
?&gt;  
</code></pre><p>通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。随着不断从服务器接收数据，readyState的值就会周期性地变为3，当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。</p>
<p>只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后，通过progress回调函数来处理传入的新数据。而当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;HTTP Streaming Example&lt;/title&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;script&gt;  
        function createStreamingClient(url, progress, finished){  
            //三个参数分别是：要连接的URL、在接收到数据时调用的函数以及关闭连接时调用的函数  
            var xhr = new XMLHttpRequest(),  
                received = 0;  

            xhr.open(&quot;get&quot;, url, true);  
            xhr.onreadystatechange = function(){  
                var result;  
                if (xhr.readyState == 3){  
                    //只取得最新数据并调整计数器  
                    result = xhr.responseText.substring(received);  
                    received += result.length;  

                    //调用progress回调函数  
                    progress(result);  

                } else if (xhr.readyState == 4){  
                    //finished函数是用来关闭连接的  
                    finished(xhr.responseText);  
                }  
            };  
            xhr.send(null);  
            return xhr;  
        }  

        var client = createStreamingClient(&quot;streaming.php&quot;, function(data){  
                        alert(&quot;Received: &quot; + data);  
                     }, function(data){  
                        alert(&quot;Done!&quot;);  
                     });  

    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="八-服务器发送事件"><a href="#八-服务器发送事件" class="headerlink" title="八.服务器发送事件"></a>八.服务器发送事件</h1><p>SSE（Server-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的Javascript API能解析的格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。</p>
<p>1.SSE API<br>SSE是为javascript api与其他传递消息的javascript api很相似。要预定新的事件流，要创建新的EventSource对象，并传入一个入口点：<br>var source=new EventSource(“myevents.php”);</p>
<p>注意：要传入的URL必须与创建对象的页面同源。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭连接。另外还有以下三个事件：<br>open：在建立连接时触发<br>message：在从服务器接收到新事件时触发<br>error：在无法建立连接时触发<br>服务器返回的数据以字符串的格式保存在event.data中。<br>默认情况下，EventSource对象会保存于服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。</p>
<p>2.事件流<br>所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/event-stream。响应的格式是纯文本。<br>Demo<br>index.html<br>[html] view plain copy<br>在CODE上查看代码片派生到我的代码片</p>
<pre><code>&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;SSE&lt;/title&gt;  
    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;!-- 实现服务器数据推送，例如股票时时刷新等 --&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;&lt;/span&gt;  
</code></pre><p>index.js</p>
<pre><code>var source;  
function init(argument){  
    source = new EventSource(&apos;http://localhost/sse/data.php&apos;);  
    source.onopen=function(){  
        console.log(&apos;连接已建立&apos;,this.readyState);  
    }  
    source.onmessage=function(event){  
        console.log(&apos;从服务器时时获取的数据&apos;,event.data);  
    }  
    source.onerror=function(){  

    }  
}  
init();  
</code></pre><p>data.php</p>
<pre><code>&lt;?php  
header(&quot;Content-Type:text/event-stream;charset=utf-8&quot;);  
header(&quot;Access-Control-Allow-Origin:http://127.0.0.1/&quot;);  
echo &quot;data:现在北京时间是&quot;.date(&apos;H:i:s&apos;).&quot;\r\n\r\n&quot;;  
 ?&gt;  
</code></pre><h1 id="九-Web-Sockets"><a href="#九-Web-Sockets" class="headerlink" title="九.Web Sockets"></a>九.Web Sockets</h1><p>web sockets使用了自定义的协议。未加密的协议是ws://;加密的协议是wss://。<br>要创建web sockets，先实例一个WebSocket对象并传入要连接的URL：<br>var sockets=new WebSockets(“ws://www.example.com/server.php”);<br>注意，必须给WebSockets构造函数传入绝对的URL。同源策略对它不适用，因此可以通过它打开到任何站点的连接。</p>
<p>关闭WebSocket连接：<br>sockets.close();   //关闭<br>发送和接收数据：<br>sockets.send(“Hello word”);//可以发送字符串，json格式的字符串<br>sockets的事件有onmessage：当服务器向客户端发来消息时，WebSocket对象就会触发message事件，这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。</p>
<pre><code>Socket.onmessage=function(event){  
var data=event.data;  
//处理数据  
 }  
</code></pre><p>其他事件：<br>open：在成功建立连接时触发；<br>error：在发生错误时触发，连接不能持续；<br>close：在连接关闭时触发。close事件的event对象有三个额外的属性：wasClean,code,reason。其中，wasClean是一个布尔值，表示连接是否已经明确地关闭；code是服务器返回的数值状态码，而reason是一个字符串，包含服务器发回的消息。</p>
<p>Web Socket协议不同于HTTP，所以现有的服务器不能用Web Socket通信。SSE倒是通过常规HTTP通信，因此现有服务器就可以满足需求。要是双向的通信，Web Sockets更好一些。在不能使用Web Sockets的情况下，组合XHR+SSE也能实现双向通信。</p>
<p>WebSocket 协议是html5引入的一种新的协议，其目的在于实现了浏览器与服务器全双工通信。看了上面链接的同学肯定对过去怎么低效率高消耗（轮询或comet）的做此事已经有所了解了，而在websocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。同时这么做有两个好处：<br>1.通信传输字节减少：比起以前使用http传输数据，websocket传输的额外信息很少<br>2.服务器可以主动向客户端推送消息，而不用客户端去查询</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/22/ajax/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          ajax
        
      </div>
    </a>
  
  
    <a href="/2016/06/04/XMLHTTPRequest2级/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">XMLHTTPRequest2级</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="跨域总结" data-title="跨域总结" data-url="http://yoursite.com/2016/06/14/跨域总结/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 chandayang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>