<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>chandayang&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I&apos;m coding">
<meta property="og:type" content="website">
<meta property="og:title" content="chandayang's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="chandayang's blog">
<meta property="og:description" content="I&apos;m coding">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chandayang's blog">
<meta name="twitter:description" content="I&apos;m coding">
  
    <link rel="alternative" href="/atom.xml" title="chandayang&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar" src='images/IMG_0832.JPG'>
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">chandayang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">前端程序媛一枚</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						<li>友情链接</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/前端工具/" style="font-size: 10px;">前端工具</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">chandayang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">chandayang</h1>
			</hgroup>
			
			<p class="header-subtitle">前端程序媛一枚</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-ajax" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/22/ajax/" class="article-date">
  	<time datetime="2016-06-22T06:18:48.000Z" itemprop="datePublished">2016-06-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/22/ajax/">ajax</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Ajax：异步的JavaScript和xml</p>
<p>Ajax 的核心是XMLHttpRequest对象，该对象为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步方式从服务器取得更多信息，用户不需要刷新页面也能取得数据。</p>
<p>同步和异步<br>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。<br>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。<br>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</p>
<h1 id="一、创建ajax过程"><a href="#一、创建ajax过程" class="headerlink" title="一、创建ajax过程"></a>一、创建ajax过程</h1><h3 id="1-创建一个XMLHttpRequest对象"><a href="#1-创建一个XMLHttpRequest对象" class="headerlink" title="(1)创建一个XMLHttpRequest对象"></a>(1)创建一个XMLHttpRequest对象</h3><pre><code>function createXhr(){  
            if(typeof XMLHttpRequest !=&quot;undefined&quot;){//主流浏览器(firefox、chrome、safari、opera、IE7以上)  
                return new XMLHttpRequest();  
            }else if(typeof ActiveXObject !=&quot;undefined&quot;){//IE浏览器创建  
                return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  
            }  
        }  
        var xhr=createXhr();  


&lt;span style=&quot;white-space:pre&quot;&gt;&lt;/span&gt;
        var xhr = null;  
        //这里如果直接写XMLHttpRequest，如果浏览器不支持XMLHttpRequest，则会报错  
        //window.XMLHttpRequest这样写，是将XMLHttpRequest当做window对象的属性来检查  
        //如果不存在会返回undefined，不会出错  
        if (window.XMLHttpRequest) {  
            xhr = new XMLHttpRequest();  
        } else {  
            xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  
        }  
</code></pre><h3 id="2-使用XMLHttpRequest对象的open方法创建一个新的HTTP请求"><a href="#2-使用XMLHttpRequest对象的open方法创建一个新的HTTP请求" class="headerlink" title="(2)使用XMLHttpRequest对象的open方法创建一个新的HTTP请求"></a>(2)使用XMLHttpRequest对象的open方法创建一个新的HTTP请求</h3><p>open方法接收三个参数：要发送请求的类型(get或者post)、请求的url、表示是否异步发送请求的布尔值<br>false表示同步请求，true表示异步请求<br>open方法并不会真正发送请求，而只是启动一个请求以备发送</p>
<h3 id="3-设置响应HTTP请求状态变化的函数"><a href="#3-设置响应HTTP请求状态变化的函数" class="headerlink" title="(3)设置响应HTTP请求状态变化的函数."></a>(3)设置响应HTTP请求状态变化的函数.</h3><p>onreadystatechange()函数</p>
<pre><code>xhr.onreadystatechange=function(){  
            if(xhr.readyState==4){  
                if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304){  
                    console.log(xhr.responseText);  
                }else{  
                    console.log(&quot;请求失败：&quot;+xhr.status);  
                }  
            }  
        }  
</code></pre><h3 id="4-发送HTTP请求"><a href="#4-发送HTTP请求" class="headerlink" title="(4)发送HTTP请求."></a>(4)发送HTTP请求.</h3><p>send方法，该方法接收一个参数，及要作为请求主体发送的数据<br>调用send方法之后，请求就会被分派到服务器</p>
<h3 id="5-获取异步调用返回的数据"><a href="#5-获取异步调用返回的数据" class="headerlink" title="(5)获取异步调用返回的数据."></a>(5)获取异步调用返回的数据.</h3><h3 id="6-使用JavaScript和DOM实现局部刷新"><a href="#6-使用JavaScript和DOM实现局部刷新" class="headerlink" title="(6)使用JavaScript和DOM实现局部刷新."></a>(6)使用JavaScript和DOM实现局部刷新.</h3><h1 id="二、get请求"><a href="#二、get请求" class="headerlink" title="二、get请求"></a>二、get请求</h1><pre><code>function createXHR(){//创建Ajax对象  
        if(window.XMLHttpRequest){  
            return new XMLHttpRequest();  
        }else{  
            return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  
        }  
    }  
    var xhr=createXHR();  
    xhr.onreadystatechange=function(){  
        if(xhr.readyState==4){  
            if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304){  
                console.log(xhr.responseText);  
            }else{  
                console.log(&quot;请求失败：&quot;+xhr.status);  
            }  
        }  
    };  
    xhr.open(&apos;get&apos;,&quot;example.txt&quot;,true);//true表示发送异步请求  
    xhr.send(null);  
</code></pre><h1 id="三、post请求"><a href="#三、post请求" class="headerlink" title="三、post请求"></a>三、post请求</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;UTF-8&quot;&gt;  
    &lt;title&gt;Document&lt;/title&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
     function checkname(){  
        //ajax方式用户名校验  
        //1、获取用户名信息  
        var nm=document.getElementById(&quot;username&quot;).value;  
        //对传递的特殊字符串进行编码处理  tn&amp;age=34  
        //同时对中文也会进行编码处理  
        nm=encodeURIComponent(nm);  
        //把用户名信息变为“请求字符串“  
        var info=&quot;name=&quot;+nm+&quot;&amp;age=23&quot;;  
        //2、ajax校验  
        var xhr=new XMLHttpRequest();  
        xhr.onreadystatechange=function(){  
            if(xhr.readyState==4){  
                alert(xhr.responseText);  
            }  
        }  
        xhr.open(&apos;post&apos;,&apos;./05.php?addr=beijing&apos;);  
        //post方式传递数据是模拟form表单传递数据  
        //form表单的post格式数据是通过xml形式传递给服务器的  
        xhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  
        xhr.send(info);  
     }  
    &lt;/script&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;h2&gt;ajax用户名的校验(post方式)&lt;/h2&gt;  
   &lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; onblur=&quot;checkname()&quot;&gt;&lt;/p&gt;  
   &lt;p&gt;手机号码：&lt;input type=&quot;text&quot; id=&quot;usertel&quot;&gt;&lt;/p&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="四、GET和POST的区别，何时使用POST？"><a href="#四、GET和POST的区别，何时使用POST？" class="headerlink" title="四、GET和POST的区别，何时使用POST？"></a>四、GET和POST的区别，何时使用POST？</h1><p>get和post方式区别：</p>
<ol>
<li>GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给服务器。在Ajax请求中，这种区别对用户是不可见的。</li>
</ol>
<p>2.GET方式对传输的数据大小有限制(通常不能大于2KB)，而使用POST方式传递的数据量要比GET方式大的多(理论上不受限制)</p>
<p>3.GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全性问题，而POST方式相对来说就比较安全。</p>
<p>4.GET方式和POST方式传递的数据在服务器端的获取也不相同。在PHP中，GET方式的数据可以用$_GET[]获取，POST使用$_POST[]获取。两种方式都可以使用$_REQUEST[]来获取。</p>
<p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。<br>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
<p>然而，在以下情况中，请使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<p>get请求需要注意的地方：</p>
<p>1.缓存(将请求地址缓存起来，如果下一次请求地址不变，则下次请求的内容将读取缓存中的数据，而不会去请求服务器上的数据)<br>我们可以通过在url？后面连接一个随机数或者时间戳来解决这一问题<br>2.传递中文参数乱码问题，通过编码encodeURI来解决</p>
<pre><code>&lt;body&gt;  
&lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;提交数据&quot; id=&quot;btn&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
var oBtn = document.getElementById(&quot;btn&quot;);  
oBtn.onclick = function(){  
    var xhr = new XMLHttpRequest();  
    xhr.open(&apos;get&apos;,&apos;get_form.php?username=&apos;+encodeURI(&apos;李四&apos;)+&apos;&amp;age=123&amp;&apos;+new Date().getTime(),true);  
    xhr.send();  
    xhr.onreadystatechange = function(){  
    if(xhr.readyState == 4){  
        if(xhr.status == 200){  
            alert(xhr.responseText);  
        }  
    }  
}  
}  
&lt;/script&gt;  
&lt;/body&gt;  
</code></pre><p>get_form.php</p>
<pre><code>&lt;?php  
header(&quot;content-type:text/html;charset=utf-8&quot;);  
$username = $_GET[&apos;username&apos;];  
$age = $_GET[&apos;age&apos;];  
echo &quot;欢迎哈哈哈,你的名字是:{$username},年龄是:{$age}&quot;;  
 ?&gt;  
</code></pre><p>post请求需要注意的地方：<br>1.post方式，数据放在send()里面作为参数传递<br>2.需要声明要发送的数据的类型<br>xhr.setRequestHeader(‘content-type’, ‘application/x-www-form-urlencoded’);<br>这里如果不设置Content-Type头部信息，那么发送给服务器的数据就不会出现在$_POST超级全局变量中。</p>
<pre><code>&lt;body&gt;  
&lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;提交数据&quot; id=&quot;btn&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
var oBtn = document.getElementById(&quot;btn&quot;);  
oBtn.onclick = function(){  
    var xhr = new XMLHttpRequest();  
    xhr.open(&apos;post&apos;,&apos;post_form.php&apos;,true);  
    //post方式，数据放在send()里面作为参数传递  
    xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);//声明发送的数据类型  
    xhr.send(&apos;username=李四&amp;age=300&apos;);  
    //post方式没有缓存问题和编码问题  
    xhr.onreadystatechange = function(){  
    if(xhr.readyState == 4){  
        if(xhr.status == 200){  
            alert(xhr.responseText);  
        }  
    }  
}  
}  
&lt;/script&gt;  
&lt;/body&gt;  
</code></pre><p>post_form.php</p>
<pre><code>&lt;?php  
header(&quot;content-type:text/html;charset=utf-8&quot;);  
$username = $_POST[&apos;username&apos;];  
$age = $_POST[&apos;age&apos;];  
echo &quot;你的名字是:{$username},年龄是:{$age}&quot;;  
 ?&gt;  
</code></pre><h1 id="五、XMLHttpRequest对象"><a href="#五、XMLHttpRequest对象" class="headerlink" title="五、XMLHttpRequest对象"></a>五、XMLHttpRequest对象</h1><p>它的属性有：</p>
<p>onreadystatechange  每次状态改变所触发事件的事件处理程序。<br>responseText     作为响应主体被返回的文本。<br>responseXML  将响应信息格式化为Xml Document对象并返回<br>status           响应的HTTP状态，比如常见的404（未找到）和200（已成功）<br>status Text      HTTP状态说明</p>
<p>当XHR对象把一个HTTP请求发送到服务器的过程中会经历几个状态，直到请求被处理，然后才接收一个回应。readyState就是XHR请求的状态属性，它本身有5个属性值：</p>
<p>0：未初始化。尚未调用open()方法</p>
<p>1：启动。已经调用open()方法,但尚未调用send()方法</p>
<p>2：发送。已经调用send()方法，但尚未接收到响应</p>
<p>3：接收。已经接收到部分响应数据     </p>
<p>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了</p>
<p>只要readyState属性的值由一个值变成另一个值，都会触发一次onreadystatechange事件。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。</p>
<p>不过，必须要在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性<br>六、http状态码</p>
<p>1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。</p>
<p>2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<p>3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。</p>
<p>4字头：客户端错误。这类状态码代表了客户端看起来可能发生错误，妨碍了服务器的处理。</p>
<p>5字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>
<p>100 Continue</p>
<p>  初始的请求已经接受，客户应当继续发送请求的其余部分</p>
<p>101 Switching Protocols</p>
<p>  服务器将遵从客户的请求转换到另外一种协议</p>
<p>201 Created</p>
<p>  服务器已经创建了文档，Location头给出了它的URL。</p>
<p>202 Accepted</p>
<p>  已经接受请求，但处理尚未完成。</p>
<p>203 Non-Authoritative Information</p>
<p>  文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</p>
<p>204 No Content</p>
<p>  没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的</p>
<p>205 Reset Content</p>
<p>  没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</p>
<p>206 Partial Content</p>
<p>  客户发送了一个带有Range头的GET请求，服务器完成了它</p>
<p>300 Multiple Choices</p>
<p>  客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</p>
<p>301 Moved Permanently</p>
<p>  客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</p>
<p>302 Found</p>
<p>  类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。</p>
<p>303 See Other</p>
<p>  类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取</p>
<p>305 Use Proxy</p>
<p>  客户请求的文档应该通过Location头所指明的代理服务器提取</p>
<p>307 Temporary Redirect</p>
<p>  和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。</p>
<p>400 Bad Request</p>
<p>  请求出现语法错误。</p>
<p>401 Unauthorized</p>
<p>  客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。</p>
<p>403 Forbidden</p>
<p>  资源不可用。</p>
<p>405 Method Not Allowed</p>
<p>  请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。</p>
<p>406 Not Acceptable</p>
<p>  指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容</p>
<p>407 Proxy Authentication Required</p>
<p>  类似于401，表示客户必须先经过代理服务器的授权。</p>
<p>408 Request Timeout</p>
<p>  在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。</p>
<p>409 Conflict</p>
<p>  通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。</p>
<p>410 Gone</p>
<p> 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。</p>
<p>411 Length Required</p>
<p>  服务器不能处理请求，除非客户发送一个Content-Length头。</p>
<p>412 Precondition Failed</p>
<p> 请求头中指定的一些前提条件失败</p>
<p>413 Request Entity Too Large</p>
<p>  目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头</p>
<p>414 Request URI Too Long</p>
<p>  URI太长</p>
<p>416 Requested Range Not Satisfiable</p>
<p>  服务器不能满足客户在请求中指定的Range头</p>
<p>501 Not Implemented</p>
<p>  服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</p>
<p>502 Bad Gateway</p>
<p>  服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</p>
<p>503 Service Unavailable</p>
<p>  服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头</p>
<p>504 Gateway Timeout</p>
<p>  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</p>
<p>505 HTTP Version Not Supported</p>
<p>  服务器不支持请求中所指明的HTTP版本</p>
<h1 id="七、HTTP头部信息"><a href="#七、HTTP头部信息" class="headerlink" title="七、HTTP头部信息"></a>七、HTTP头部信息</h1><p>Accept 表示浏览器能够处理的内容类型</p>
<p>Accept-Encoding 表示浏览器能够处理的压缩编码</p>
<p>Accept-Language 表示浏览器当前设置的语言</p>
<p>Host 表示发出请求的页面所在的域</p>
<p>Referer 表示发出请求页面的URI</p>
<p>User-Agent 表示浏览器的用户代理字符串</p>
<p>Connection  Keep-Alive   浏览器与服务器之间连接的类型</p>
<h1 id="八、传统Ajax问题"><a href="#八、传统Ajax问题" class="headerlink" title="八、传统Ajax问题"></a>八、传统Ajax问题</h1><p>1、可以无刷新改变页面内容，但无法改变页面URL</p>
<p>2、为了更好的可访问性，内容发生改变后，通常改变URL的hash</p>
<p>3、hash的方式不能很好的处理浏览器的前进、后退等问题，进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变。但这种方式对搜索引擎很不友好，twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。</p>
<h1 id="九、Ajax模拟登陆"><a href="#九、Ajax模拟登陆" class="headerlink" title="九、Ajax模拟登陆"></a>九、Ajax模拟登陆</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;ajax登录&lt;/title&gt;  
    &lt;style type=&quot;text/css&quot;&gt;  
    *{  
        margin: 0;  
        padding: 0;  
        list-style: none;  
        text-decoration: none;  
        outline: none;  
    }  
    a{  
        display: inline-block;  
        position: absolute;  
        top: 10px;  
        right: 30px;  
    }  
    .box{  
        display: none;  
        width: 300px;  
        height: 300px;  
        position: absolute;  
        top:50%;  
        left:50%;  
        margin-top: -150px;  
        margin-left: -150px;  
        /*border:1px solid #ccc;*/  
        padding: 10px;  
        z-index: 9999;  
        background: #fff;  
    }  
    .list{  
        margin-top: 15px;  
    }  
    .list label{  
        display: inline-block;  
        text-align: right;   
        width: 80px;  
    }  
    .input_list{  
        display: inline-block;  
        margin-left: 10px;  
    }  
    .input_list .sub{  
        padding: 5px;  
        width: 80px;  
        cursor: pointer;  
    }  
    .mask{  
        display: none;  
        position: absolute;  
        width: 100%;  
        height: 100%;  
        background: rgba(0,0,0,.5);  
        z-index: 999;  
    }  
    &lt;/style&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;a href=&quot;javascript:;&quot; id=&quot;link&quot;&gt;登录&lt;/a&gt;  
&lt;div class=&quot;box&quot;&gt;  
    &lt;form action=&quot;#&quot;&gt;  
        &lt;div class=&quot;list&quot;&gt;  
        &lt;label&gt;姓名:&lt;/label&gt;  
        &lt;div class=&quot;input_list&quot;&gt;  
            &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入你的姓名&quot;&gt;  
        &lt;/div&gt;  
        &lt;/div&gt;  
        &lt;div class=&quot;list&quot;&gt;  
        &lt;label&gt;密码:&lt;/label&gt;  
        &lt;div class=&quot;input_list&quot;&gt;  
            &lt;input type=&quot;password&quot; name=&quot;pwd&quot; id=&quot;pwd&quot; placeholder=&quot;请输入你的密码&quot;&gt;  
        &lt;/div&gt;  
        &lt;/div&gt;  
        &lt;div class=&quot;list&quot;&gt;  
        &lt;label&gt;家庭住址:&lt;/label&gt;  
        &lt;div class=&quot;input_list&quot;&gt;  
            &lt;input type=&quot;text&quot; name=&quot;address&quot; id=&quot;address&quot; placeholder=&quot;请输入你的住址&quot;&gt;  
        &lt;/div&gt;  
        &lt;/div&gt;  
        &lt;div class=&quot;list&quot;&gt;  
            &lt;label&gt;&lt;/label&gt;  
            &lt;div class=&quot;input_list&quot;&gt;  
                &lt;input type=&quot;button&quot; class=&quot;sub&quot; value=&quot;提交&quot; id=&quot;subBtn&quot;&gt;  
            &lt;/div&gt;  
        &lt;/div&gt;  
    &lt;/form&gt;  
&lt;/div&gt;  
&lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
$(function(){  
    $(&quot;#link&quot;).click(function(){  
        $(&quot;.box&quot;).show();  
        $(&quot;.mask&quot;).show();  
    });  
    $(&quot;#subBtn&quot;).click(function(){  
        var url = &quot;http://localhost/mywork/ajax_login/test.php&quot;;  
        var obj = {  
        username : $(&quot;#username&quot;).val(),  
        password : $(&quot;#pwd&quot;).val()  
          };  
        // console.log(obj);  
        $(&quot;.box&quot;).hide();  
        $(&quot;.mask&quot;).hide();  
        $.post(url,obj,function(data){  
            if(data == &quot;yes&quot;){  
                alert(&quot;登录成功&quot;);  
                $(&quot;#link&quot;).html(&quot;欢迎 &quot;+$(&apos;#username&apos;).val()+&quot; 登陆&quot;);  
            }else{  
                alert(&quot;登录失败&quot;);  
            }  
        });  
    });  
});  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>test.php</p>
<pre><code>&lt;?php  
$username=$_POST[&apos;username&apos;];  
$password=$_POST[&apos;password&apos;];  
if($username == &apos;admin&apos; &amp;&amp; $password == &apos;123&apos;){  
    echo &quot;yes&quot;;  
}else{  
    echo &quot;no&quot;;  
}  
?&gt;  
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-跨域总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/14/跨域总结/" class="article-date">
  	<time datetime="2016-06-14T05:53:34.000Z" itemprop="datePublished">2016-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/跨域总结/">跨域总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javascript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略指定：JavaScript只能访问与包含它的文档在同一域下的内容。所谓同源是指，域名(host)，协议(protocol)，端口(port)相同。</p>
<p>URL     说明  是否跨域<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="http://www.abc.com/b.js" target="_blank" rel="external">http://www.abc.com/b.js</a>     同一域名下   否<br><a href="http://www.abc.com/test/a.js" target="_blank" rel="external">http://www.abc.com/test/a.js</a><br><a href="http://www.abc.com/lib/b.js" target="_blank" rel="external">http://www.abc.com/lib/b.js</a>     同一域名下不同文件夹  否<br><a href="http://www.abc.com:80/a.js" target="_blank" rel="external">http://www.abc.com:80/a.js</a><br><a href="http://www.abc.com/b.js" target="_blank" rel="external">http://www.abc.com/b.js</a>     同一域名，不同端口号  是<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="https://www.abc.com/b.js" target="_blank" rel="external">https://www.abc.com/b.js</a>    同一域名，不同协议(http和https)   是<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="http://127.0.0.1/b.js" target="_blank" rel="external">http://127.0.0.1/b.js</a>   域名与域名对应IP   是<br><a href="http://www.abc.com/a.js" target="_blank" rel="external">http://www.abc.com/a.js</a><br><a href="http://abc.com/b.js" target="_blank" rel="external">http://abc.com/b.js</a><br><a href="http://www.test.com/b.js" target="_blank" rel="external">http://www.test.com/b.js</a>    不同域名(host)  是</p>
<h1 id="一-ajax设置Access-Control-Allow-Origin实现跨域访问"><a href="#一-ajax设置Access-Control-Allow-Origin实现跨域访问" class="headerlink" title="一.ajax设置Access-Control-Allow-Origin实现跨域访问"></a>一.ajax设置Access-Control-Allow-Origin实现跨域访问</h1><p>通过XHR实现Ajax通信的一个主要限制，来源与跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。</p>
<p>CORS(Cross-Origin Resource Sharing,跨源资源共享)是W3C的一个标准，定义了在必须访问跨资源时，浏览器与服务器应该如何沟通。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。其背后的基本思想是：就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>对于简单的get或post发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送请求时，需要给它附加一个额外的Origin头部，其中包含请求页面的源信息(协议、域名和端口号)，以便服务器根据这个头部信息来决定是否给予响应。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息(origin头)，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>例子：</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
      &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;cors_post&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function createXhr(){  
            if(typeof XMLHttpRequest){  
                return new XMLHttpRequest();  
            }else if(typeof ActiveXObject){  
                return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);  
            }  
        }  
        var xhr=createXhr();  
        var data={  
            name:&quot;liujie&quot;,  
            age:&quot;23&quot;  
        };  
        xhr.onreadystatechange=function(){  
            if(xhr.readyState==4){  
                if(xhr.status==200){  
                    //console.log(xhr.responseText);  
                    document.getElementById(&quot;box&quot;).innerHTML=data.name+&apos;---&apos;+data.age;  
                }  
            }  
        }  
        xhr.open(&quot;post&quot;,&quot;http://www.abc.com/21code/cors/post.php&quot;,true);  
        xhr.send(data);  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>请求页面post.php:</p>
<pre><code>&lt;?php  
header(&apos;content-type:application:json;charset=utf8&apos;);  
// 指定允许其他域名访问  
//header(&apos;Access-Control-Allow-Origin:http://www.example.com&apos;);  
header(&apos;Access-Control-Allow-Origin:*&apos;);  
// 响应类型  
header(&apos;Access-Control-Allow-Methods:POST&apos;);  
$res= array(  
    &apos;name&apos; =&gt; isset($_POST[&apos;name&apos;])? $_POST[&apos;name&apos;] : &apos;&apos;,  
    &apos;gender&apos; =&gt; isset($_POST[&apos;gender&apos;])? $_POST[&apos;gender&apos;] : &apos;&apos;  
);  
echo json_encode($res);  
 ?&gt; 
&lt;img src=&quot;http://img.blog.csdn.net/20160809155156139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; /&gt;  
</code></pre><p>通过<a href="http://www.example.com访问这个页面，Origin:http://www.example.com" target="_blank" rel="external">http://www.example.com访问这个页面，Origin:http://www.example.com</a></p>
<p>如果服务器认为这个请求可以接收，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发”*”）。</p>
<p>比如：Access-Control-Allow-Origin：<a href="http://www.example.com" target="_blank" rel="external">http://www.example.com</a></p>
<p>如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。<br>cors基本流程：<br>1.浏览器对于AJAX请求会自动在头信息之中，添加一个Origin字段，该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>2.如果Origin指定的域名在许可范围内，服务器返回的响应，并在响应头的Access-Control-Allow-Origin头部中会发相同的源信息。<br>与CORS请求相关的字段：</p>
<p>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（3）Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（4）Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<br>（5）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true时，Cookie就会包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（6）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。例如：getResponseHeader(‘FooBar’)可以返回FooBar字段的值。<br>withCredentials 属性<br>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<pre><code>Access-Control-Allow-Credentials: true  
</code></pre><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<pre><code>var xhr = new XMLHttpRequest();  
xhr.withCredentials = true;  
</code></pre><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。<br>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<pre><code>xhr.withCredentials = false;  
</code></pre><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。<br>与jsonp的区别：</p>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h1 id="二、图像Ping"><a href="#二、图像Ping" class="headerlink" title="二、图像Ping"></a>二、图像Ping</h1><p>使用img标签，我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。</p>
<p>动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。来看下面的例子。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;Image Ping Example&lt;/title&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;script&gt;  
        var img = new Image();  
        img.onload = img.onerror = function(){  
            alert(&quot;Done!&quot;);  
        };  
        img.src = &quot;http://www.example.com/ajax?name=test&quot;;  
    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>这里创建了一个Image的实例，然后将onload和onerror事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置src属性那一刻开始，而这个例子在请求中发送了一个name参数。</p>
<p>图像Ping最常用于跟踪用户点页面或动态广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。因此，图像Ping只能用于浏览器与服务器间的单向通信。</p>
<h1 id="三、jsonp实现跨域"><a href="#三、jsonp实现跨域" class="headerlink" title="三、jsonp实现跨域"></a>三、jsonp实现跨域</h1><p>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里</p>
<p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>
<p>首先在客户端注册一个callback, 然后把callback的名字传给服务器。此时，服务器先生成 json 数据。然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的参数 jsonp.最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）</p>
<p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
<p>jsonp允许在服务器端集成Script 标签返回至客户端，通过javascript回调函数的形式实现跨域访问。它可以绕过同源策略的方法，即通过使用JSON与script标签相结合的方法，从服务器直接返回可执行的javascript函数调用或者javascript对象。</p>
<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
<p>1.在<a href="http://example.com/jsonp/目录下有个remote.js文件代码如下：" target="_blank" rel="external">http://example.com/jsonp/目录下有个remote.js文件代码如下：</a></p>
<pre><code>alert(&quot;我是远程服务器上的文件&quot;);  
</code></pre><p>在<a href="http://www.example.com/jsonp/目录下有个jsonp.html页面代码如下：" target="_blank" rel="external">http://www.example.com/jsonp/目录下有个jsonp.html页面代码如下：</a></p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;jsonp01&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://example.com/jsonp/remote.js&quot;&gt;&lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>访问jsonp.html页面将会弹出一个提示窗体，显示跨域调用成功。</p>
<p>2.在jsonp02.html页面定义一个函数，然后在远程remote.js中传入数据进行调用</p>
<p>jsonp02.html页面代码如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;jsonp02&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    //现在我们在jsonp02.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。  
     var localHandler = function(data){  
        alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result);  
    };  
    &lt;/script&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://example.com/jsonp/remote.js&quot;&gt;&lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>remote.js文件代码如下：</p>
<pre><code>localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});  
</code></pre><p>访问jsonp.html页面,成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。</p>
<p>3、动态生成script标签</p>
<p>jsonp03.html页面的代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;jsonp03&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
     // 得到学生信息查询结果后的回调函数  
    var flightHandler = function(data){  
        alert(&apos;你查询的学生信息结果是：姓名:&apos; + data.name+&apos;--&apos;+ &apos;年龄:&apos; + data.age);  
    };  
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）  
    var url = &quot;http://example.com/jsonp/remote.js?num=001&amp;callback=flightHandler&quot;;  
    // 创建script标签，设置其属性  
    var script = document.createElement(&apos;script&apos;);  
    script.src=url;  
    // 把script标签加入head，此时调用开始  
    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>remote.js文件代码如下：</p>
<pre><code>flightHandler({  
    &quot;num&quot;: &quot;001&quot;,  
    &quot;name&quot;: &quot;lisi&quot;,  
    &quot;age&quot;: 25  
});  
</code></pre><p>调用的url中传递了一个num参数，告诉服务器我要查的是001的学生信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。我们看到，传递给flightHandler函数的是一个json，它描述了学生的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！<br>jQuery对jsonp的实现</p>
<p>原理是一样的，只不过我们不需要手动的插入script标签以及定义回掉函数。jQuery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。</p>
<p>jquery对jsonp的支持：<br>两种方式：getJSON()方法和ajax指定返回jsonp类型<br>使用getJSON()方法时，必须指定callback=?，表示使用使用jsonp的方式来发起请求</p>
<p>$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<p>getJSON()方法：Demo</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;jsonp&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;input type=&quot;button&quot; value=&quot;jsonp跨域&quot; onclick=&quot;testJsonp()&quot;&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    function testJsonp(){  
        $.getJSON(&apos;http://b.test.com/mywork/kuayu/jsonp/jsopn.php?callback=?&apos;,  
            function(data){  
            console.log(data);  
        })  
    }  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>jsonp.php</p>
<pre><code>&lt;?php  
$jsonp = $_REQUEST[&quot;callback&quot;];  
$str = &apos;{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:23}&apos;;  
$str = $jsonp . &quot;(&quot; .$str.&quot;)&quot;;  
echo $str;  
?&gt;  
</code></pre><p>ajax指定返回jsonp类型：Demo</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;jsonp&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;input type=&quot;button&quot; value=&quot;jsonp跨域&quot; onclick=&quot;testJsonp()&quot;&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
/*  
这里jQuery将自动把URL里的回调函数，例如&quot;url?callback=?&quot;中的后一个&quot;?&quot;替换为正确的函数名，以执行回调函数  
 */  
    function testJsonp(){  
        $.ajax(&apos;http://b.test.com/mywork/kuayu/jsonp/jsopn.php?callback=?&apos;,  
            {dataType:&apos;jsonp&apos;,  
        }).done(function(data){  
            console.log(data);  
        });  
    }  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>$.ajax()跨域原理分析<br>由于javascript的安全限制“同源策略”，所以我们无法使用XMLHttpRequest直接请求别的域名下的资源。不过拥有src属性和href属性的<code>&lt;script&gt;\&lt;img&gt;\&lt;iframe&gt;</code>和<code>&lt;link&gt;\&lt;a&gt;</code>标签不受同源策略影响。$.ajax()正是应用了动态创建<code>&lt;script&gt;</code>的方式来实现（即：生成<code>&lt;script&gt;</code>标签，<code>src</code>引入脚本，然后执行，最后移除<code>&lt;script&gt;</code>标签）。</p>
<h1 id="四、通过修改document-domain来跨子域"><a href="#四、通过修改document-domain来跨子域" class="headerlink" title="四、通过修改document.domain来跨子域"></a>四、通过修改document.domain来跨子域</h1><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域</p>
<p>主域相同的使用document.domain</p>
<p>假设有一个页面，它的地址是<a href="http://www.example.com/abc.html，在这个页面里面有一个iframe，它的src是http://example.com/ab.html" target="_blank" rel="external">http://www.example.com/abc.html，在这个页面里面有一个iframe，它的src是http://example.com/ab.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西。</p>
<p>这时在页面 <a href="http://example.com/ab.html" target="_blank" rel="external">http://example.com/ab.html</a> 和<a href="http://www.example.com/abc.html中设置相同的document.domain，这样我们就可以通过js访问到iframe中的各种属性和对象了。" target="_blank" rel="external">http://www.example.com/abc.html中设置相同的document.domain，这样我们就可以通过js访问到iframe中的各种属性和对象了。</a></p>
<p><a href="http://www.example.com/abc.html页面代码：" target="_blank" rel="external">http://www.example.com/abc.html页面代码：</a></p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;通过修改document.domain来跨子域&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;iframe src=&quot;http://example.com/ab.html&quot; id=&quot;iframe&quot; onload=&quot;test()&quot;&gt;&lt;/iframe&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    document.domain=&quot;example.com&quot;;//设置成主域  
    function test(){  
        var iframe=document.getElementById(&quot;iframe&quot;);  
        var win=iframe.contentWindow;  
        var doc=win.document;  
        var name=win.name;  
        alert(win);  
        alert(doc);  
       alert(name);  
    }  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p><a href="http://example.com/ab.html页面代码：" target="_blank" rel="external">http://example.com/ab.html页面代码：</a></p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;通过修改document.domain来跨子域&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    document.domain=&quot;example.com&quot;;//设置成主域  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="五、使用window-name来进行跨域"><a href="#五、使用window-name来进行跨域" class="headerlink" title="五、使用window.name来进行跨域"></a>五、使用window.name来进行跨域</h1><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>
<pre><code>http://www.example.com/mywork/kuayu/windowname/aaa.html页面代码：  

&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;使用window.name来进行跨域&lt;/title&gt;  
        &lt;script type=&quot;text/javascript&quot;&gt;  
         function getData(){//iframe载入data.html页面后会执行此函数  
        var iframe=document.getElementById(&quot;iframe&quot;);  
        iframe.onload=function(){//这个时候aaa.html与iframe已经是处于同一源了，可以互相访问  
            var data=iframe.contentWindow.name;//获取iframe里的window.name，也就是data.html页面给它设置的数据  
            alert(data);//成功获取到了data.html里的数据  
        };  
        iframe.src=&quot;http://www.example.com/mywork/kuayu/windowname/a.html&quot;;//这里的a.html为随便的一个页面，只要与aaa.html同源就行，目的是让aaa.html能访问到iframe里的东西，设置成about:blank也行  
    }  
    &lt;/script&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;iframe style=&quot;display:none;&quot; src=&quot;http://example.com/mywork/kuayu/windowname/data.html&quot; id=&quot;iframe&quot; onload=&quot;getData()&quot;&gt;&lt;/iframe&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  

http://example.com/mywork/kuayu/windowname/data.html页面代码：  

&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;使用window.name来进行跨域&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    window.name=&quot;我是页面aaa.html想要的数据&quot;;  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>整个跨域的流程是这样的：<br>先在<a href="http://example.com/mywork/kuayu/windowname/data.html中通过一些操作将数据存入window.name中了" target="_blank" rel="external">http://example.com/mywork/kuayu/windowname/data.html中通过一些操作将数据存入window.name中了</a><br>而<a href="http://www.example.com/mywork/kuayu/windowname/aaa.html想要获取到window.name的值就需要依靠iframe作为中间代理，首先把iframe的src设置成http://example.com/mywork/kuayu/windowname/data.html，这样就相当于要获取iframe的window.name，而要想获取到iframe中的window.name，就需要把iframe的src设置成当前域的一个页面地址&quot;http://www.example.com/mywork/kuayu/windowname/aa.html&quot;或者设置成about:blank也行，不然根据前面讲的同源策略，window.name.html是不能访问到iframe里的window.name属性的。" target="_blank" rel="external">http://www.example.com/mywork/kuayu/windowname/aaa.html想要获取到window.name的值就需要依靠iframe作为中间代理，首先把iframe的src设置成http://example.com/mywork/kuayu/windowname/data.html，这样就相当于要获取iframe的window.name，而要想获取到iframe中的window.name，就需要把iframe的src设置成当前域的一个页面地址&quot;http://www.example.com/mywork/kuayu/windowname/aa.html&quot;或者设置成about:blank也行，不然根据前面讲的同源策略，window.name.html是不能访问到iframe里的window.name属性的。</a> </p>
<h1 id="六-跨文档消息传递"><a href="#六-跨文档消息传递" class="headerlink" title="六 跨文档消息传递"></a>六 跨文档消息传递</h1><p>跨文档消息传送(cross-document messaging)，简称XDM，指的是在来自不同域的页面间传递消息。<br>这个例子就是位于www.example.com域中的页面postmessage.html与位于一个内嵌框架中的www.abc.com域中的页面postmessage2.html通信。</p>
<p>XDM的核心是postMessage()方法，利用这个方法向另外一个地方传递数据。这里另外一个地方指的是包含在当前页面中的<code>&lt;iframe&gt;</code>元素，或者由当前页面弹出的窗口。 postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。如果传给postMessage()方法的第二个参数是”*”，则表示可以把消息发送给来自任何域的文档。</p>
<pre><code>接收到跨文档消息传送的消息时，会触发window对象的message事件，这个事件是以异步形式触发的
要想接收从其他窗口发过来的消息，必须对窗口对象的message事件进行监听

传给onmessage处理程序的事件对象包含以下三个方面的重要信息：
data:作为postMessage()方法第一个参数传入的字符串数据，可以通过message事件的data属性获取消息的内容
origin:发送消息的文档所在的域，可以通过message事件的origin属性获取消息的发送源
source:发送消息的文档的window对象的代理，可以通过message事件的source属性可以获取消息发送源的窗口对象
</code></pre><p>Demo</p>
<p>postmessage.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;UTF-8&quot;&gt;  
    &lt;title&gt;跨文档消息传递&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;  
    &lt;div&gt;  
        &lt;input type=&quot;text&quot; size=&quot;40&quot; id=&quot;msg&quot; placeholder=&quot;请输入内容&quot;&gt;  
        &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;Send to iframe&quot;&gt;  
    &lt;/div&gt;  
    &lt;iframe id=&quot;inner&quot; width=&quot;450&quot; height=&quot;300&quot; src=&quot;http://www.abc.com/HTML5/postMessage/postmessage2.html&quot;&gt;&lt;/iframe&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;../EventUtil.js&quot;&gt;&lt;/script&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    EventUtil.addHandler(window,&apos;message&apos;,function(event){  
        var content=document.getElementById(&quot;content&quot;);  
        content.innerHTML=&quot;iframe said:&quot;+event.data;  
        //event.source.postMessage(&quot;1页面收到消息&quot;,&quot;http://www.abc.com&quot;);  
    });  
    EventUtil.addHandler(document.getElementById(&quot;btn&quot;),&quot;click&quot;,function(event){  
        //msg中存放的是要发送给另一个页面的消息  
        var msg=document.getElementById(&quot;msg&quot;).value;  
        innerWindow=document.getElementById(&quot;inner&quot;).contentWindow;  

        if(innerWindow.postMessage){  
            //*表示可以把消息发送给来自任何域的文档  
            innerWindow.postMessage(msg,&quot;http://www.abc.com/HTML5/postMessage/postmessage2.html&quot;);  
        }else{  
            alert(&quot;Your browser doesn&apos;t support Cross Document Messaging.&quot;);  
        }  
    });  
    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>postmessage2.html页面</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;UTF-8&quot;&gt;  
    &lt;title&gt;跨文档消息传递&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;  
&lt;div&gt;  
    &lt;input type=&quot;text&quot; id=&quot;msg&quot; size=&quot;40&quot; placeholder=&quot;请输入内容&quot;&gt;  
    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;Send to parent&quot;&gt;  
&lt;/div&gt;  
&lt;script type=&quot;text/javascript&quot; src=&quot;../EventUtil.js&quot;&gt;&lt;/script&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
EventUtil.addHandler(window,&apos;message&apos;,function(event){  
    var content=document.getElementById(&quot;content&quot;);  
    content.innerHTML=&quot;parent said:&quot;+event.data;  
    //event.source.postMessage(&quot;2页面收到消息&quot;,&quot;http://www.example.com&quot;);  
});  
EventUtil.addHandler(document.getElementById(&quot;btn&quot;),&apos;click&apos;,function(event){  
    var msg=document.getElementById(&quot;msg&quot;).value;  
    /*跨文档消息传送的核心是postMessage()方法  
    使用window对象的postMessage()方法向其他窗口发送消息  
    这个方法接收两个参数：第一个参数为所发送的消息文本；第二个参数为接收消息的对象窗口的URL地址  
    可以在URL地址字符串中使用通配符&quot;*&quot;指定全部地址，但是建议使用准确的URL地址  
    */  
   //console.log(parent);// Window  
    if(parent.postMessage){  
        parent.postMessage(msg,&quot;http://www.example.com/HTML5/postMessage/postmessage.html&quot;);/*使用通配符&quot;*&quot;指定全部地址*/  
    }else{  
        alert(&quot;Your browser doesn&apos;t support Cross Document Messaging.&quot;);  
    }  
});  
&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>注： EventUtil是封装好的一个js文件，里面定义了给元素绑定事件的一些函数。   </p>
<h1 id="七-Comet"><a href="#七-Comet" class="headerlink" title="七. Comet"></a>七. Comet</h1><p>Ajax是一种页面向服务器请求数据的技术，Comet是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时的被推送到页面上，非常适合处理体育比赛和股票报价。</p>
<p>有两种实现Comet的方式：长轮询和流。长轮询是传统轮询（即短轮询）的一个翻版，即浏览器定时向服务器发送请求，看看有没有数据更新。</p>
<p>短轮询：浏览器定时向服务器发送请求，看看有没有数据更新</p>
<p>短轮询是一种从服务器拉取数据的工作模式。设置一个定时器，定时询问服务器是否有信息，每次建立连接传输数据之后，链接会关闭</p>
<p>短轮询模式：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>
<p>长轮询把传统轮询颠倒了一下，页面发送一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。这个过程在页面打开期间一直不断持续。</p>
<p>长轮询：页面发送一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又发起一个到服务器的新请求。</p>
<p>长轮询模式：建立连接——（保持连接直到有数据可发送）…数据传输——关闭连接(随即又向服务器建立一个连接)</p>
<p>长轮询与短轮询的不同：主要在于client和server采取的关闭策略不同。短轮询在建立连接以后只进行一次数据传输就关闭连接，而长轮询在建立连接以后会进行多次数据数据传输直至关闭连接。</p>
<p>无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现，你要做的就是决定什么时候发送请求。</p>
<p>HTTP流</p>
<p>第二种流行的Comet方式是HTTP流。流不同于上述的两种轮询，它在页面的整个生命周期中只使用一个HTTP连接。具体来说就是浏览器向服务器发送一个请求，然后服务器保持连接打开，然后周期性的向浏览器发送数据。下面这段PHP脚本就是采用流实现的服务器中的常见方式：</p>
<p>streaming.php:</p>
<pre><code>&lt;?php  
$i=0;  
while(true){  
echo &quot;Number is $i&quot;;//输出一些数据，然后立即刷新输出缓存  
flush();  
sleep(10);//等几秒  
$i++;  
}  
?&gt;  
</code></pre><p>通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。随着不断从服务器接收数据，readyState的值就会周期性地变为3，当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。</p>
<p>只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后，通过progress回调函数来处理传入的新数据。而当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;HTTP Streaming Example&lt;/title&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
&lt;/head&gt;  
&lt;body&gt;  
    &lt;script&gt;  
        function createStreamingClient(url, progress, finished){  
            //三个参数分别是：要连接的URL、在接收到数据时调用的函数以及关闭连接时调用的函数  
            var xhr = new XMLHttpRequest(),  
                received = 0;  

            xhr.open(&quot;get&quot;, url, true);  
            xhr.onreadystatechange = function(){  
                var result;  
                if (xhr.readyState == 3){  
                    //只取得最新数据并调整计数器  
                    result = xhr.responseText.substring(received);  
                    received += result.length;  

                    //调用progress回调函数  
                    progress(result);  

                } else if (xhr.readyState == 4){  
                    //finished函数是用来关闭连接的  
                    finished(xhr.responseText);  
                }  
            };  
            xhr.send(null);  
            return xhr;  
        }  

        var client = createStreamingClient(&quot;streaming.php&quot;, function(data){  
                        alert(&quot;Received: &quot; + data);  
                     }, function(data){  
                        alert(&quot;Done!&quot;);  
                     });  

    &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="八-服务器发送事件"><a href="#八-服务器发送事件" class="headerlink" title="八.服务器发送事件"></a>八.服务器发送事件</h1><p>SSE（Server-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的Javascript API能解析的格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。</p>
<p>1.SSE API<br>SSE是为javascript api与其他传递消息的javascript api很相似。要预定新的事件流，要创建新的EventSource对象，并传入一个入口点：<br>var source=new EventSource(“myevents.php”);</p>
<p>注意：要传入的URL必须与创建对象的页面同源。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭连接。另外还有以下三个事件：<br>open：在建立连接时触发<br>message：在从服务器接收到新事件时触发<br>error：在无法建立连接时触发<br>服务器返回的数据以字符串的格式保存在event.data中。<br>默认情况下，EventSource对象会保存于服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。</p>
<p>2.事件流<br>所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/event-stream。响应的格式是纯文本。<br>Demo<br>index.html<br>[html] view plain copy<br>在CODE上查看代码片派生到我的代码片</p>
<pre><code>&lt;span style=&quot;font-size:14px;&quot;&gt;&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;meta charset=&quot;utf-8&quot;&gt;  
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  
    &lt;title&gt;SSE&lt;/title&gt;  
    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;!-- 实现服务器数据推送，例如股票时时刷新等 --&gt;  
    &lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;&lt;/span&gt;  
</code></pre><p>index.js</p>
<pre><code>var source;  
function init(argument){  
    source = new EventSource(&apos;http://localhost/sse/data.php&apos;);  
    source.onopen=function(){  
        console.log(&apos;连接已建立&apos;,this.readyState);  
    }  
    source.onmessage=function(event){  
        console.log(&apos;从服务器时时获取的数据&apos;,event.data);  
    }  
    source.onerror=function(){  

    }  
}  
init();  
</code></pre><p>data.php</p>
<pre><code>&lt;?php  
header(&quot;Content-Type:text/event-stream;charset=utf-8&quot;);  
header(&quot;Access-Control-Allow-Origin:http://127.0.0.1/&quot;);  
echo &quot;data:现在北京时间是&quot;.date(&apos;H:i:s&apos;).&quot;\r\n\r\n&quot;;  
 ?&gt;  
</code></pre><h1 id="九-Web-Sockets"><a href="#九-Web-Sockets" class="headerlink" title="九.Web Sockets"></a>九.Web Sockets</h1><p>web sockets使用了自定义的协议。未加密的协议是ws://;加密的协议是wss://。<br>要创建web sockets，先实例一个WebSocket对象并传入要连接的URL：<br>var sockets=new WebSockets(“ws://www.example.com/server.php”);<br>注意，必须给WebSockets构造函数传入绝对的URL。同源策略对它不适用，因此可以通过它打开到任何站点的连接。</p>
<p>关闭WebSocket连接：<br>sockets.close();   //关闭<br>发送和接收数据：<br>sockets.send(“Hello word”);//可以发送字符串，json格式的字符串<br>sockets的事件有onmessage：当服务器向客户端发来消息时，WebSocket对象就会触发message事件，这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。</p>
<pre><code>Socket.onmessage=function(event){  
var data=event.data;  
//处理数据  
 }  
</code></pre><p>其他事件：<br>open：在成功建立连接时触发；<br>error：在发生错误时触发，连接不能持续；<br>close：在连接关闭时触发。close事件的event对象有三个额外的属性：wasClean,code,reason。其中，wasClean是一个布尔值，表示连接是否已经明确地关闭；code是服务器返回的数值状态码，而reason是一个字符串，包含服务器发回的消息。</p>
<p>Web Socket协议不同于HTTP，所以现有的服务器不能用Web Socket通信。SSE倒是通过常规HTTP通信，因此现有服务器就可以满足需求。要是双向的通信，Web Sockets更好一些。在不能使用Web Sockets的情况下，组合XHR+SSE也能实现双向通信。</p>
<p>WebSocket 协议是html5引入的一种新的协议，其目的在于实现了浏览器与服务器全双工通信。看了上面链接的同学肯定对过去怎么低效率高消耗（轮询或comet）的做此事已经有所了解了，而在websocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。同时这么做有两个好处：<br>1.通信传输字节减少：比起以前使用http传输数据，websocket传输的额外信息很少<br>2.服务器可以主动向客户端推送消息，而不用客户端去查询</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-XMLHTTPRequest2级" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/04/XMLHTTPRequest2级/" class="article-date">
  	<time datetime="2016-06-04T06:30:26.000Z" itemprop="datePublished">2016-06-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/04/XMLHTTPRequest2级/">XMLHTTPRequest2级</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><h2>新旧版本对比</h2><p></p>
<p></p><h2>新旧版本对比</h2><br>老版本的XMLHttpRequest对象有以下几个缺点：<br><p></p>
<pre><code>&lt;blockquote&gt;只支持文本数据的传送，无法读取和上传二进制文件。&lt;br/&gt;传送和接收数据时，没有进度信息，只能提示有没有完成。&lt;br/&gt;
受到”同域限制”，只能向同一域名的服务器请求数据。&lt;br/&gt;&lt;/blockquote&gt;
</code></pre><p>新版本的功能<br><br>新版本的XMLHttpRequest对象的一些新功能：<br></p>
<blockquote>可以设置HTTP请求的时限。<br><br>    可以使用FormData对象管理表单数据。<br><br>    可以上传文件。<br><br>    可以请求不同域名下的数据（跨域资源共享，Cross-origin resource sharing，简称 CORS）。<br><br>    可以获取服务器端的二进制数据。<br><br>    可以获得数据传输的进度信息。<br><br></blockquote>

<h1>FormData</h1> 

<p>XMLHttpRequest 2级定义了FormData类型，这为序列化表单以及创建与表单格式相同的数据提供了便利。<br><br>新建FormData对象：</p>
<pre><code>&lt;pre&gt;var formData = new FormData();&lt;/pre&gt;   
</code></pre><p>为它添加表单项：</p>
<pre>formData.append('name', 'lisi');
formData.append('age', 12);</pre>

<p>最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。</p>
<pre>xhr.send(formData);</pre>

<p>Demo:</p>
<pre><code>&lt;!DOCTYPE html&gt;

    &lt;head&gt;
&lt;title&gt;FormData&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Fill in the form below:&lt;/p&gt;
&lt;form id=&quot;user-info&quot;&gt;
    &lt;label for=&quot;user-name&quot;&gt;姓名:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;user-name&quot; name=&quot;user-name&quot; /&gt;&lt;br&gt;
    &lt;label for=&quot;user-email&quot;&gt;Email:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;user-email&quot; name=&quot;user-email&quot; /&gt;&lt;br&gt;
    &lt;input type=&quot;button&quot; value=&quot;Submit&quot; onclick=&quot;submitData()&quot; /&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function createXHR(){
                if(typeof XMLHttpRequest){
                    return new XMLHttpRequest();
                }else if(typeof ActiveXObject){
                    return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                }
    }
    function submitData(){
        var xhr = createXHR();
        xhr.onreadystatechange = function(event){
            if (xhr.readyState == 4){
                if (xhr.status == 200 ){
                    console.log(xhr.responseText);
                } else {
                    alert(&quot;Request was unsuccessful: &quot; + xhr.status);
                }
            }
        };

        xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);
        var form = document.getElementById(&quot;user-info&quot;);
        xhr.send(new FormData(form));
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>postexample.PHP</p>
<pre><code>&lt;?php
    header(&quot;Content-Type: text/plain&quot;);
    echo &lt;&lt;&lt;EOF
    Name: {$_POST[&apos;user-name&apos;]}
    Email: {$_POST[&apos;user-email&apos;]}

?&gt;
</code></pre><p>使用FormData的方便之处在于：不必明确在xhr对象上设置请求头部，xhr对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。</p>
<p>FormData对象也可以用来获取网页表单的值：</p>
<pre><code>var form = document.getElementById(&apos;myform&apos;);
var formData = new FormData(form);
formData.append(&apos;name&apos;, &apos;lisi&apos;); // 添加一个表单项
xhr.open(&apos;POST&apos;, form.action);
xhr.send(formData);
</code></pre><p>新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限，表示请求在等待响应多少毫秒之后就停止。在给timeout属性属性设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序。</p>
<p>Demo:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Timeout事件&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function createXHR(){
                if(typeof XMLHttpRequest){
                    return new XMLHttpRequest();
                }else if(typeof ActiveXObject){
                    return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                }
    }
    var xhr = createXHR();
    xhr.onreadystatechange = function(event){
        try {
            if (xhr.readyState == 4){
                if (xhr.status == 200){
                    alert(xhr.responseText);
                } else {
                    alert(&quot;Request was unsuccessful: &quot; + xhr.status);
                }
            }
        } catch (ex){
            //assume handled by ontimeout
        }
    };
    xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);
    xhr.timeout = 1000;//给xhr对象设置了timeout属性，表示请求在等待响应1000毫秒之后停止
    xhr.ontimeout = function(){
        alert(&quot;Request did not return in a second.&quot;);
    };
    xhr.send(null);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>跨域资源共享（CORS）</p>
<p>新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做”跨域资源共享”（Cross-origin resource sharing，简称CORS）。<br>使用”跨域资源共享”的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种”跨域”。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。</p>
<p>例如：</p>
<p>xhr.open(‘post’, ‘<a href="http://localhost/test.php&#39;,true" target="_blank" rel="external">http://localhost/test.php&#39;,true</a>);</p>
<p>进度事件</p>
<p>新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。<br>它分成上传和下载两种情况：<br>1.下载的progress事件属于XMLHttpRequest对象<br>2.上传的progress事件属于XMLHttpRequest.upload对象<br>有以下6个进度事件：</p>
<pre><code>loadstart:在接收到响应数据的第一个字节时触发
progress:在接收响应期间持续不断地触发
error:在请求发生错误时触发
abort:在因为调用abort()方法而终止连续时触发
load:在接收到完整的响应数据时触发
loadend:在通信完成或者触发error、abort或load事件后触发

每个请求都是从触发loadstart事件开始，接下来是一或多个progress事件，然后触发error、abort或load事件中的一个，最后以触发loadend事件结束。
</code></pre><p>Demo:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;XHR Progress Event Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;status&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function createXHR(){
                    if(typeof XMLHttpRequest){
                        return new XMLHttpRequest();
                    }else if(typeof ActiveXObject){
                        return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                    }
        }
//主要浏览器接收到了服务器的响应，不管其状态如何，都会触发load事件。
        window.onload = function(){
            var xhr = createXHR();
            xhr.onload = function(event){
                if (xhr.status == 200){
                    console.log(xhr.responseText);
                } else {
                    alert(&quot;Request was unsuccessful: &quot; + xhr.status);
                }
            };
            xhr.onprogress = function(event){
                var divStatus = document.getElementById(&quot;status&quot;);
                if (event.lengthComputable){
                    divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;;
                }
            };
            xhr.open(&quot;get&quot;, &quot;test.php&quot;, true);
            xhr.send(null);
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>test.php</p>
<pre><code>&lt;?php
    header(&quot;Content-Type: text/plain&quot;);
    header(&quot;Content-Length: 27&quot;);
    echo &quot;Some data&quot;;
    flush();
    echo &quot;Some data&quot;;
    flush();
    echo &quot;Some data&quot;;
    flush();
?&gt;
</code></pre><p>progress事件会在浏览器接收新数据期间周期性地触发。onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象，包含三个额外的属性：</p>
<pre><code>lengthComputable:表示进度信息是否可用的布尔值
position:表示已经接收的字节数
totalSize:表示根据Content-Length响应头部确定的预期字节数
利用这些信息，我们可以为用户创建一个进度指示器
</code></pre><p>ajax无刷新上传</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;title&gt;ajax无刷新上传&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
    #div1{
        width: 300px;
        height: 30px;
        border:1px solid #000;
        position: relative;
    }
    #div2{
        width: 0;
        height: 30px;
        background: #CCC;
    }
    #div3{
        width: 300px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        position: absolute;
        left: 0;
        top: 0;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;file&quot; id=&quot;myFile&quot; name=&quot;&quot; value=&quot;&quot; placeholder=&quot;&quot;&gt;
&lt;input type=&quot;button&quot; id=&quot;btn&quot; name=&quot;&quot; value=&quot;上传&quot;&gt;
&lt;div id=&quot;div1&quot;&gt;
    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;div3&quot;&gt;0%&lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var oBtn = document.getElementById(&quot;btn&quot;);//获取上传按钮
var myFile = document.getElementById(&quot;myFile&quot;);
var oDiv2 = document.getElementById(&quot;div2&quot;);
var oDiv3 = document.getElementById(&quot;div3&quot;);
oBtn.onclick = function(){
    //alert(myFile.value);//获取到的是file控件的value值，这个内容是显示给你看的文字，不是我们选择的文件
    //myFile.files 是file控件中选择的文件列表对象
    //alert(myFile.files);//[object FileList]

    //我们是要通过ajax把myFile.files[0]数据发送给后端
    //for (var attr in myFile.files[0]) {
    //console.log( attr + &apos; : &apos; + myFile.files[0][attr] );
    // }
    var xhr = new XMLHttpRequest();
    //监听上传完成事件
    //load事件在接收到完整的响应数据时触发
    xhr.onload = function(){
        alert(&quot;上传完成&quot;);
    }
    // 监听上传进度
    var oUpload = xhr.upload;
    oUpload.onprogress = function(e){
            //e.total：待发送的总量
            //e.loaded：已经发送的总量
            //oUpload.onprogress：上传
            //onprogress：下载
            console.log(e.total + &apos;:&apos; + e.loaded);
        var iScale = e.loaded / e.total;//获取已经上传的比例
            //上传进度条
            //根据上传的比例改变进度条div的宽度(初始宽度为0)
            oDiv2.style.width = 300 * iScale + &apos;px&apos;;
            //上传进度的百分比显示
            oDiv3.innerHTML = 100 * iScale + &apos;%&apos;;
    };
    xhr.open(&apos;post&apos;,&apos;post_file.php&apos;,true);//post请求
    var oFormData = new FormData();
    //append方法接收两个参数：分别对象表单字段名称和表单字段值
    oFormData.append(&apos;file&apos;,myFile.files[0]);
    xhr.send(oFormData);
};
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>post_file.php</p>
<pre><code>&lt;?php
header(&apos;Content-type:text/html; charset=&quot;utf-8&quot;&apos;);
//uploads--用来存放上传成功的文件
$upload_dir = &apos;uploads/&apos;;
//strtolower把所有字符转换为小写
//如果发送客户端发送的不是post请求，则给出相应的错误信息并退出
if(strtolower($_SERVER[&apos;REQUEST_METHOD&apos;]) != &apos;post&apos;){
    exit_status(array(&apos;code&apos;=&gt;1,&apos;msg&apos;=&gt;&apos;错误提交方式&apos;));
}
//检查键名是否存在于数组中
//array_key_exists(key,array)，存在则返回true
//$_FILES[&apos;myFile&apos;][&apos;error&apos;] 和该文件上传相关的错误代码
if(array_key_exists(&apos;file&apos;,$_FILES) &amp;&amp; $_FILES[&apos;file&apos;][&apos;error&apos;] == 0 ){
    $pic = $_FILES[&apos;file&apos;];
    //move_uploaded_file() 函数将上传的文件移动到新位置
    //第一个参数表示要移动的文件，第二个参数为文件的新位置
    //若成功，则返回 true，否则返回 false
    if(move_uploaded_file($pic[&apos;tmp_name&apos;], $upload_dir.$pic[&apos;name&apos;])){
        exit_status(array(&apos;code&apos;=&gt;0,&apos;msg&apos;=&gt;&apos;上传成功&apos;,&apos;url&apos;=&gt;$upload_dir.$pic[&apos;name&apos;]));
    }
}
echo $_FILES[&apos;file&apos;][&apos;error&apos;];
exit_status(array(&apos;code&apos;=&gt;1,&apos;msg&apos;=&gt;&apos;出现了一些错误&apos;));
//将关联数组转为json字符串，并退出
function exit_status($str){
    echo json_encode($str);
    exit;
}
?&gt;


    $_FILES[“file”][“name”] - 被上传文件的名称
    $_FILES[“file”][“type”] - 被上传文件的类型
    $_FILES[“file”][“size”] - 被上传文件的大小，以字节计
    $_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称
    $_FILES[“file”][“error”] - 由文件上传导致的错误代码
</code></pre><p>用promise实现ajax</p>
<p>Demo：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;title&gt;ajax的Promise实现&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function ajax(method,url,data,bool){
    var promise = new Promise(function(resolve,reject){
        var xhr = new XMLHttpRequest();
        xhr.open(method,url,bool);
        xhr.onreadystatechange = function(){
            if(xhr.readyState == 4){
                if(xhr.status == 200){
                    resolve(xhr.responseText);
                }else{
                    reject(new Error(xhr.statusText));
                }
            }
        };
        // xhr.responseType = &quot;json&quot;;
        // xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
        xhr.send(data);
    });
    return promise;
}
ajax(&quot;get&quot;,&quot;http://localhost/mywork/promise/post.json&quot;,null,false).then(function(data){
    data = JSON.parse(data);//服务器返回的是一个json字符串
    console.log(data.name+&quot;--&quot;+data.age);//lisi--12
},function(error){
    console.error(&quot;出错了:&quot;+error);//出错了:Error: Not Found
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>post.json</p>
<pre><code>{
    &quot;name&quot;:&quot;lisi&quot;,
    &quot;age&quot;:12
  }
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/18/webpack学习/" class="article-date">
  	<time datetime="2016-05-18T07:11:44.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/webpack学习/">webpack学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Webpack 是什么</p>
<p>webpack是一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>简单说就是模块加载器，通过使用Webpack，能够像Node.js一样处理依赖关系，然后解析出模块之间的依赖，将代码打包。<br>为什么需要打包？</p>
<pre><code>像sass，JSX等代码虽然极大的提高了开发效率，但是本身并不被浏览器所识别，需要我们对其进行编译和打包，变成浏览器识别的代码
模块化(让我们可以把复杂的代码细化为小的文件)
优化加载速度(压缩和合并代码来提高加载速度，压缩可以减少文件体积，代码合并可以减少http请求)
使用新的开发模式
</code></pre><p>webpack主要特性如下：</p>
<pre><code>同时支持CommonJS和AMD模块（对于新项目，推荐直接使用CommonJS）；
串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持；
可以基于配置或者智能分析打包成多个文件，实现公共模块或者按需加载；
支持对CSS，图片等资源进行打包，从而无需借助Grunt或Gulp(browserify只能打包JS文件)；
开发时在内存中完成打包，性能更快，完全可以支持开发过程的实时打包需求；
对source map有很好的支持。
</code></pre><p>Source map(使调试更容易)</p>
<p>Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，这将给开发者带来了很大方便。</p>
<p>安装 Webpack</p>
<p>首先得安装Node.js</p>
<pre><code>全局环境下安装，在任意目录，输入以下命令

    //这是为了能够在全局环境中使用webpack命令
    //非全局安装需使用node_modules/.bin/webpack
    $ npm install webpack -g

仅在项目在中安装，切换到项目根目录，输入以下命令

    $ npm install webpack --save-dev

检查是否安装成功，显示如下：

    $ webpack -v
</code></pre><p>安装成功示例<br>更快捷的执行打包任务</p>
<pre><code>{
 &quot;name&quot;: &quot;demo&quot;,
 &quot;version&quot;: &quot;1.0.0&quot;,
&quot;description&quot;: &quot;&quot;,
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --progress --colors --hot --inline -d&quot;,
    &quot;build&quot;: &quot;webpack --progress --colors --minify&quot;
},
&quot;license&quot;: &quot;ISC&quot;,
&quot;dependencies&quot;: {
},
&quot;devDependencies&quot;: {
 }
}
</code></pre><p>执行类似于node_modules/.bin/webpack这样的命令不仅繁琐还容易出错，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start或者npm run build命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如上面的配置所示。</p>
<p><strong>注意：</strong>npm的start是一个特殊的脚本名称，它的特殊性在于：在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如上面例子中的npm run build。</p>
<p><strong>特别说明：</strong>package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。<br>配置</p>
<p>每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。<br>webpack.config.js配置详解<br>这里给出我自己的配置：</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);
module.exports = {
 noParse:[/jquery/]，//表示跳过jquery,不对其进行编译,这样可以提高打包的速度
 plugins:[
 commonsPlugin，
 //配置了NoErrorsPlugin插件，用来跳过编译时出错的代码并记录，使编译后运行时的包不会发生错误
 new webpack.NoErrorsPlugin()
 ],
 entry: {
     index:&apos;./src/js/startup.js&apos;
 },
//入口文件输出配置
 output:{
     //path: 打包好的资源存放的位置
     path:&apos;./js&apos;,
     //filename: 打包后的文件名
     filename: &apos;[name].bundle.js&apos;
 },
 // externals: {     //排除构建文件外
//        &apos;react&apos;: &apos;React&apos;
//    },
 module: {
     //加载器配置
     //module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理
    loaders:[
     {
       //用于匹配加载器支持的文件格式的正则表达式
        test: /\.css$/,
        //多个加载器通过&quot;!&quot;连接,加载器是从右向左开始使用的
        //loader指定了要使用的加载器类型
        loader: &apos;style-loader!css-loader&apos;
    },
     {
     //配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式 （其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）
          test: /\.(png|jpg)$/,
          //加载器支持通过查询字符串的方式接收参数
           loader: &apos;url-loader?limit=8192&apos;
     },
     {
     //presets:指定哪些代码转换器将启用babel
         test: /\.js$/, 
         loader: &apos;babel-loader&apos;,
//exclude:/node_modules/,排除node_modules这个文件夹中的代码
 //include:/(admin|consumer)//表示只针对这两个文件夹中的代码进行打包
//include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）
         exclude:/node_modules/,
         query:{
         presets:[&apos;es2015&apos;,&apos;react&apos;]
         }
     },
     {
         test: /\.jsx$/, 
         //?表示加载器支持通过查询字符串的方式接收参数
        //!表示多个加载器之间通过&quot;!&quot;连接
         loader: &apos;babel-loader!jsx-loader?harmony&apos;
     }
     ]
 },
</code></pre><p>//文件解析配置</p>
<p>//会依次寻找不带后缀的文件，.js后缀文件以及.jsx后缀文件。先找到哪个是哪个</p>
<pre><code>resolve: { 
extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;],//当requrie的模块找不到时，添加这些后缀
root:&apos;E:/myev/src&apos;,//绝对路径
alias: {//别名配置

    }
 }
}
</code></pre><p> }</p>
<p>这里对Webpack的打包行为做了配置，主要分为几个部分：</p>
<pre><code>plugins 是插件项(是一个数组)：这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。对于用到的插件，只需要将插件new出来放到数组中即可。
entry：指定打包的入口文件，每有一个键值对，就是一个入口文件
output：配置打包结果，path定义了输出的文件夹(即打包好的文件要放到哪里)，filename则定义了打包结果文件的名称，filename里面的[name]会由entry中的键（这里是index）替换。publicPath:如果要使用webpack-dev-server(webpack配置服务器，端口号是8080)就需要配置(标明我们要从哪个地方获取打包好的文件)
externals：当我们想在项目中require一些其他的类库或者API，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。此时我们就可以通过配置externals参数来解决这个问题。
resolve：定义了解析模块路径时的配置，常用的就是extensions，可以用来指定模块的后缀，这样在引入模块时就不需要写后缀了，会自动补全。比如 Hello.jsx 这样的文件就可以直接用 require(./Hello) 引用。 resolve 配置，配置查找模块的路径和扩展名和别名（方便书写）。可以用 alias 指定从非npm引入的库，如
</code></pre><p>jQuery:path.resolve(__dirname,’./bower_components/jquery/dist/jquery.js’) ，<br>这样在 import 时可以替换引用路径。</p>
<ul>
<li>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。比如这里定义了凡是.js结尾的文件都是用babel-loader做处理，而.jsx结尾的文件会先经过babel-loader处理，然后经过jsx-loader处理。当然这些loader也需要通过npm install安装，“-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。</li>
</ul>
<p>Webpack还有很多其他的配置，具体可以参照它的配置文档<br>对应各种不同文件类型的资源, Webpack 有对应的模块 loader。比如 CoffeeScript 用的是 coffee-loader, 其他还有很多。请参考相关文档<br>在 Webpack 当中, 所有的资源都被当作是模块, js, css, 图片等等。因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl。</p>
<p>Webpack的加载器支持参数，jsx-loader就可以添加?harmony参数使其支持ES6语法。为了让Webpack识别什么样的资源应该用什么加载器去载入，需要在配置文件进行配置：通过正则表达式对文件名进行匹配。</p>
<p>加载器之间的级联是通过感叹号来连接，例如对于LESS资源，写法为style-loader!css-loader!less-loader。从右向左开始使用，less-&gt;转为css字符串-&gt;使用style将代码放到页面style标签中。<br>css-loader——将样式打包成字符串<br>style-load——将样式字符串添加到页面的style标签中<br>对于小型的图片资源，也可以将其进行统一打包，由url-loader实现，代码中url-loader?limit=8192含义就是对于所有小于8192字节的图片资源也进行打包。这在一定程度上可以替代Css Sprites方案，用于减少对于小图片资源的HTTP请求数量。<br>执行打包</p>
<p>如果通过npm install -g webpack方式安装webpack的话，可以通过命令行直接执行打包命令，比如：<br>$ webpack –config webpack.config.js<br>这样就会读取当前目录下的webpack.config.js作为配置文件执行打包操作</p>
<p>常用webpack命令：<br>在开发环境构建一次<br>webpack<br>构建并生成源代码映射文件<br>webpack -d<br>在生成环境构建，压缩、混淆代码，并移除无用代码<br>webpack -p<br>快速增量构建，可以和其他选项一起使用<br>webpack –watch<br>progress 显示打包过程中的进度，colors打包信息带有颜色显示<br>webpack –progress –colors<br>理解文件路径</p>
<p>require(‘lodash’) // 从模块目录查找<br>require(‘./file’) // 按相对路径查找<br>CSS 及图片的引用</p>
<p>require(‘./bootstrap.css’);<br>require(‘./myapp.less’);</p>
<p>var img = document.createElement(‘img’);<br>img.src = require(‘./glyph.png’);</p>
<p>一个模块需要用它的文件路径来加载，看一下下面的这个结构：</p>
<p>–app<br>——modules<br>———–MyModule.js<br>——main.js (entry point，入口文件)<br>——utils.js</p>
<p>打开 main.js 然后可以通过下面两种方式引入 app/modules/MyModule.js</p>
<p>app/main.js</p>
<p>// ES6<br>import MyModule from ‘./modules/MyModule.js’;</p>
<p>// CommonJS<br>var MyModule = require(‘./modules/MyModule.js’);</p>
<p>最开始的 ./ 是 “相对当前文件路径”<br>让我们打开 MyModule.js 然后引入 app/utils：</p>
<p>app/modules/MyModule.js</p>
<p>// ES6 相对路径<br>import utils from ‘./../utils.js’;</p>
<p>// ES6 绝对路径<br>import utils from ‘/utils.js’;</p>
<p>// CommonJS 相对路径<br>var utils = require(‘./../utils.js’);</p>
<p>// CommonJS 绝对路径<br>var utils = require(‘/utils.js’);</p>
<p>相对路径是相对当前目录。绝对路径是相对入口文件，这个案例中是 main.js。<br>CommonChunks插件</p>
<p>Common Chunks 插件的作用：提取代码中的公共模块，然后将公共模块打包到一个独立的文件中去，以便在其它的入口和模块中使用。<br>我们在配置项中添加CommonChunksLoader的配置，使用它来提取公共模块。</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
var config = {
entry:{
    main1:&apos;./main1&apos;,
    main2:&apos;./main2&apos;
},
output:{
    filename:&apos;bundle.[name].js&apos;
},
plugins: [
    new  webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;, [&apos;main1&apos;, &apos;main2&apos;])
]
 };
module.exports = config;
</code></pre><p>在配置文件中添加了webpack的引用（同时也要在项目目录下安装webpack），然后添加了plugins选项，引用了webpack.optimize.CommonsChunkPlugin来提取公共模块，参数common.js表示公共模块的文件名，后面的数组元素与entry一一对应，表示要提取这些模块中的公共模块。<br>重新使用webpack打包后，看到生成的文件中多了一个common.js</p>
<p>这个common.js正是公共部分a和b两个模块。而生成的bundle.main1.js中只包含了c模块，bundle.main2.js中则没有包含任何其它模块。</p>
<p>最后要在HTML文件中引入公共部分common.js。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
&lt;title&gt;CommonsChunkPlugin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;common.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;bundle.main1.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行结果：<br>这里写图片描述<br>其他插件功能</p>
<p>OccurenceOrderPlugin：给经常使用的模块分配最小长度的id，这样可以减少文件大小。</p>
<p>HotModuleReplacementPlugin：是热替换，热替换和dev-server的hot有什么区别？不用刷新页面，可用于生产环境。</p>
<p>NoErrorsPlugin：在打包时不会因为错误而中断</p>
<p>ProvidePlugin: 定义一些在import时能自动引入的变量，如定义了 $: ‘jquery’ 后，可以在文件中直接使用$，webpack可以自动帮你加上 var $ = require(‘jquery’)。</p>
<p>DllPlugin: 将一些模块预编译，类似windows里的dll，可以在项目中直接使用，无需再构建。注意要在output中指定 library ，并在DllPlugin中指定与其一致的 name ，在有多个入口时可以使用 [name] 和 [hash] 来区分，因为这个参数是要赋值到global上的，所以这里使用 [hash] 不容易出现变量名冲突的情况。</p>
<p>DllReferencePlugin: 引用之前打包好的dll文件，注意下context参数，这个应该根据manifest.json文件中的引用情况来赋值，如果引用的都是npm安装的库，这里就填项目根目录就好了。</p>
<p>DefinePlugin: 可以定义编译时的全局变量，有很多库（React, Vue等）会根据 NODE_ENV 这个变量来判断当前环境。为了尽可能减少包大小，在生产环境中要定义其为 JSON.stringify(“production”)</p>
<p>optimize.UglifyJsPlugin: 配置压缩代码。</p>
<p>optimize.DedupePlugin: 可以减少重复文件数。</p>
<p>ExtractTextPlugin: 可以将所有css文件打包到一个css文件中。</p>
<p>Webpack-dev-server</p>
<p>Webpack有一个非常好用的功能叫做热替换（Hot-replace），尤其是结合React Hot Loader插件，开发过程中都不需要刷新浏览器，任何前端代码的更改都会实时的在浏览器中表现出来。<br>需要安装Webpack-dev-server,一个轻量的node.js express服务器。</p>
<pre><code>npm install webpack-dev-server --save-dev
</code></pre><p>webpack-dev-server有两种模式支持自动刷新——iframe模式和inline模式。<br>注意：<br>iframe模式下：页面是嵌套在一个iframe下的**，在代码发生改变的时候，这个iframe会重新加载；<br>使用iframe模式无需额外的配置，只需在浏览器输入<br>    <a href="http://localhost:8080/webpack-dev-server/index.html" target="_blank" rel="external">http://localhost:8080/webpack-dev-server/index.html</a><br>在inline模式下：一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面。<br>使用inline模式有两种方式：命令行方式和Node.js API。<br>命令行方式比较简单，只需加入–line选项即可。例如：</p>
<pre><code>webpack-dev-server --inline
</code></pre><p>使用–inline选项会自动把webpack-dev-server客户端加到webpack的入口文件配置中。<br>其他相关参数介绍：</p>
<pre><code>webpack-dev-server --progress --colors --hot --inline -p -d;
</code></pre><p>–progress 显示打包进度</p>
<p>–colors配置打包输出颜色显示</p>
<p>–hot热加载，代码修改完后自动刷新</p>
<p>–inline 是刷新后的代码自动注入到打包后的文件中(当源文件改变时会自动刷新页面)</p>
<p>-d 是debug模式，输入一个source-map，并且可以看到每一个打包的文件</p>
<p>-p 是对代码进行压缩</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端工具/">前端工具</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/08/js设计模式/" class="article-date">
  	<time datetime="2016-05-08T13:53:43.000Z" itemprop="datePublished">2016-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/08/js设计模式/">js中的设计模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在学习jQuery插件编写时用到了单例模式。于是乎想着把常用的设计模式做下总结，深化下自己的理解。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保类只能被实例化一次。<br>在该实例不存在的情况下，可以通过一个方法创建一个类来实现创建类的新实例；如果实例已经存在，它直接返回该对象的引用。<br>在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
var mySingleton = {
name:&quot;lisi&quot;,
age:23,
sayName:function(){
    console.log(&quot;Hello lisi&quot;);
}
};
&lt;/script&gt;
</code></pre><p>如果以后要扩展该对象，你可以添加自己的私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露你想暴露的public成员和方法，样例代码如下：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
var mySingleton = function(){
//声明私有变量和方法
var name = &quot;lisi&quot;;
function showName(){
    console.log(name);
}
//公有变量和方法(可以访问私有变量和方法)
return {
    publicMethod:function(){
        showName();
    },
    publicVar:&quot;我是公有变量&quot;
};
};
var single = mySingleton();
single.publicMethod();//lisi
console.log(single.publicVar);//我是公有变量
&lt;/script&gt;
&lt;   script type=&quot;text/javascript&quot;&gt;
var mySingleton = (function(){
var instance;//保存实例的引用
function init(){
    //私有变量和函数
    var privateVar = &quot;lisi&quot;;
    function privateMethod(){
        console.log(privateVar);
    }
    return {
        //公有变量和函数
        publicMethod :function(){
            privateMethod();
        },
        publicVar:&quot;我是公有变量&quot;
    };
}
return {
    getInstance:function(){
        if(!instance){
            //只有在用到的时候才进行初始化
            instance = init();
        }
        //如果存在则直接返回，不存在则新初始化一个实例
        return instance;
    }
};
})();
mySingleton.getInstance().publicMethod();//lisi
console.log(mySingleton.getInstance().publicVar);//我是公有变量
&lt;/script&gt;
</code></pre><h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>该模式使用闭包封装私有状态和组织。它提供了一种包装混合公有/私有方法和变量的方式，防止其泄漏至全局作用域，并与别的开发人员的接口发生冲突。通过该模式，只需返回一个公有API，其他的一切则都维持在私有闭包里。<br>jQuery等类库封装就采用了模块模式。<br>Demo:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
var myModule = (function(){
    //私有变量
    var myPrivateVar = 12;
    //私有函数
    var myPrivateMethod = function(foo){
        console.log(foo);
    };
    return {
        //公有变量
        myPublicVar:&quot;foo&quot;,
        //调用私有变量和方法的公有函数
        myPublicMethod:function(bar){
            //增加私有变量计数器值
            myPrivateVar++;
            myPrivateMethod(bar);
        }
    };
})();
console.log(myModule.myPublicVar);//foo
myModule.myPublicMethod(&quot;hello world&quot;);//hello world
&lt;/script&gt;
</code></pre><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。<br>使用观察者模式的好处：</p>
<p>   支持简单的广播通信，自动通知所有已经订阅过的对象。</p>
<p>   页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</p>
<p>   发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。</p>
<p>   JS里对观察者模式的实现是通过回调来实现的</p>
<pre><code>Demo：

&lt;script type=&quot;text/javascript&quot;&gt;
function Observer() {
    this.fns = [];//存放回调的数组
}
Observer.prototype = {
    //增加一个订阅
    subscribe: function (fn) {
        this.fns.push(fn);
    },
    //删除一个订阅
    unsubscribe: function (fn) {
        //过滤退订的函数
        this.fns = this.fns.filter(function (el) {
                            if (el !== fn) {
                                return el;
                            }
                        }
                    );
    },
    //发布
    public: function (args, thisObj) {
        var scope = thisObj || window;
        // console.log(scope);//window
        this.fns.forEach(function (el) {
                            el.call(scope, args);
                        }
                    );
    }
};
//创建一个pubsub对象
//该对象原型上有发布、订阅、退订三个方法
var o = new Observer();
var f1 = function (data) {
    console.log(&apos;王五: &apos; + data + &apos;, 赶紧干活了！&apos;);
};
var f2 = function (data) {
    console.log(&apos;李四: &apos; + data + &apos;, 找他加点工资去！&apos;);
};
//订阅
o.subscribe(f1);
o.subscribe(f2);
//发布
o.public(&quot;老板回来了！&quot;);
//王五退订
o.unsubscribe(f1);
//再次发布，只会触发李四对应的回调
o.public(&quot;老板回来了！&quot;);
&lt;/script&gt;
</code></pre><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>对于构造函数大家都不陌生，构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。我们可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。</p>
<pre><code>Demo:

&lt;script type=&quot;text/javascript&quot;&gt;
function Person(name,age){
    this.name = name;
    this.age = age;
    this.sayInfo = function(){
        console.log(this.name + &quot;---&quot; + this.age);
    }
}
var person1 = new Person(&quot;lisi&quot;,23);
var person2 = new Person(&quot;wangwu&quot;,24);
person1.sayInfo();//lisi---23
person2.sayInfo();//wangwu---24
//这样貌似看上去很完美，但是sayInfo()在每次创建对象的时候都重新定义了(下面代码返回false表明，两个实例的sayInfo不是同一个)，最好的方法是让所有Person类型的实例都共享这个sayInfo()方法，这样如果有大批量的实例的话，就会节约很多内存。
console.log(person1.sayInfo == person2.sayInfo);//false
&lt;/script&gt;
</code></pre><h2 id="原型-构造函数"><a href="#原型-构造函数" class="headerlink" title="原型+构造函数"></a>原型+构造函数</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function Person(name,age){
    this.name = name;
    this.age = age;
}
//这样一来，所有实例都共享sayInfo方法
Person.prototype.sayInfo = function(){
    console.log(this.name + &quot;---&quot; + this.age);
}
var person1 = new Person(&quot;lisi&quot;,23);
var person2 = new Person(&quot;wangwu&quot;,24);
person1.sayInfo();//lisi---23
person2.sayInfo();//wangwu---24
console.log(person1.sayInfo == person2.sayInfo);//true
&lt;/script&gt;
</code></pre><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式就好比现实生活中的工厂可以产生大量相似的产品，工厂模式适用于：做同样的事情，实现相同的效果。其解决了创建多个相似对象的问题。</p>
<pre><code>Demo:

&lt;script type=&quot;text/javascript&quot;&gt;
function createPerson(name,age,job){
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.job = job;
    obj.sayInfo = function(){
        console.log(this.name+&quot;--&quot;+this.age+&quot;--&quot;+this.job);
    };
    return obj;
}
var person1 = createPerson(&quot;lisi&quot;,23,&quot;student&quot;);
var person2 = createPerson(&quot;wangwu&quot;,34,&quot;worker&quot;);
person1.sayInfo();//lisi--23--student
person2.sayInfo();//lisi--23--student
//返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列
console.log(typeof person1);//object
console.log(typeof person2);//object
&lt;/script&gt;
</code></pre><p>函数createPerson能接受三个参数name,age,job等参数，可以无数次调用这个函数，每次返回都会包含三个属性和一个方法的对象。<br>工厂模式是为了解决多个类似对象声明的问题;也就是为了解决实列化对象产生重复的问题(避免了产生大量的重复代码)。<br>优点：解决了创建多个相似对象的问题<br>缺点：没有解决对象识别的问题(即怎样确定一个对象的类型)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js执行环境与上下文" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/16/js执行环境与上下文/" class="article-date">
  	<time datetime="2016-04-16T07:24:44.000Z" itemprop="datePublished">2016-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/16/js执行环境与上下文/">js执行环境与上下文</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先，我们要知道执行环境和作用域是两个完全不同的概念。</p>
<p>函数的每次调用都有与之紧密相关的作用域和执行环境。从根本上来说，作用域是基于函数的，而执行环境是基于对象的(例如：全局执行环境即window对象)。<br>换句话说，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。执行环境始终是this关键字的值，它是拥有当前所执行代码的对象的引用。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br>执行环境（也称执行上下文–execution context）</p>
<p>当JavaScript解释器初始化执行代码时，它首先默认进入全局执行环境，从此刻开始，函数的每次调用都会创建一个新的执行环境。<br>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着。<br>执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化，this的值也会被最终确定。在执行阶段，代码被解释执行。<br>Demo：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function Fn1(){
    function Fn2(){
        alert(document.body.tagName);//BODY
        //other code...
    }
    Fn2();
}
Fn1();
&lt;/script&gt;
</code></pre><p>小结</p>
<p>当javascript代码被浏览器载入后，默认最先进入的是一个全局执行环境。当在全局执行环境中调用执行一个函数时，程序流就进入该被调用函数内，此时JS引擎就会为该函数创建一个新的执行环境，并且将其压入到执行环境堆栈的顶部。浏览器总是执行当前在堆栈顶部的执行环境，一旦执行完毕，该执行环境就会从堆栈顶部被弹出，然后，进入其下的执行环境执行代码。这样，堆栈中的执行环境就会被依次执行并且弹出堆栈，直到回到全局执行环境。<br>此外还要注意一下几点：</p>
<pre><code>单线程
同步执行
唯一的全局执行环境
局部执行环境的个数没有限制
每次某个函数被调用，就会有个新的局部执行环境为其创建，即使是多次调用的自身函数(即一个函数被调用多次，也会创建多个不同的局部执行环境)。
</code></pre><p>作用域</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链包含了执行环境栈中的每个执行环境对应的变量对象。通过作用域链，可以决定变量的访问和标识符的解析。<br>注意：全局执行环境的变量对象始终都是作用域链的最后一个对象。</p>
<p>在访问变量时，就必须存在一个可见性的问题(内层环境可以访问外层中的变量和函数，而外层环境不能访问内层的变量和函数)。更深入的说，当访问一个变量或调用一个函数时，JavaScript引擎将不同执行环境中的变量对象按照规则构建一个链表，在访问一个变量时，先在链表的第一个变量对象上查找，如果没有找到则继续在第二个变量对象上查找，直到搜索到全局执行环境的变量对象即window对象。这也就形成了Scope Chain的概念。<br>这里写图片描述<br>特别说明：图片来自于笨蛋的座右铭博客<br>作用域链图，清楚的表达了执行环境与作用域的关系(一一对应的关系)，作用域与作用域之间的关系(链表结构，由上至下的关系)。</p>
<p>Demo:</p>
<pre><code>var color = &quot;blue&quot;;
function changeColor(){
var anotherColor = &quot;red&quot;;
function swapColors(){
var tempColor = anotherColor;
anotherColor = color;
color = tempColor;
// 这里可以访问color, anotherColor, 和 tempColor
}
 // 这里可以访问color 和 anotherColor，但是不能访问 tempColor
 swapColors();
}
changeColor();
// 这里只能访问color
console.log(&quot;Color is now &quot; + color);
</code></pre><p>上述代码一共包括三个执行环境：全局执行环境、changeColor()的局部执行环境、swapColors()的局部执行环境。</p>
<pre><code>全局环境有一个变量color和一个函数changecolor();
changecolor()函数的局部环境中具有一个anothercolor属性和一个swapcolors函数，当然，changecolor函数中可以访问自身以及它外围（即全局环境）中的变量;
swapcolor()函数的局部环境中具有一个变量tempcolor。在该函数内部可以访问上面的两个环境（changecolor和window）中的所有变量，因为那两个环境都是它的父执行环境。
上述代码的作用域链如下图所示：

从上图发现。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。
标识符解析（变量名或函数名搜索）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后（全局执行环境）回溯，直到找到标识符为止。
</code></pre><p>执行环境与作用域的区别与联系</p>
<p>执行环境为全局执行环境和局部执行环境，局部执行环境是函数执行过程中创建的。<br>作用域链是基于执行环境的变量对象的，由所有执行环境的变量对象(对于函数而言是活动对象，因为在函数执行环境中，变量对象是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO(变量对象)的角色。)共同组成。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途：是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。<br>小练习</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
(function(){
a= 5;
console.log(window.a);//undefined
var a = 1;//这里会发生变量声明提升
console.log(a);//1
})();
&lt;/script&gt;
</code></pre><p>window.a之所以是undefined，是因为var a = 1;发生了变量声明提升。相当于如下代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
(function(){
var a;//a是局部变量
a = 5;//这里局部环境中有a，就不会找全局中的
console.log(window.a);//undefined
a = 1;//这里会发生变量声明提升
console.log(a);//1
})();
&lt;/script&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js继承学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/04/js继承学习/" class="article-date">
  	<time datetime="2016-04-04T05:39:39.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/js继承学习/">js继承学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js里常用的如下两种继承方式：<br>原型链继承（对象间依靠原型链来实现继承）</p>
<p>类式继承（在子类型构造函数的内部调用超类型的构造函数）</p>
<p>由于js不像Java那样是真正面向对象的语言，js是基于对象的，它没有类的概念。所以，要想实现继承，可以用js的原型<br>prototype机制或者用apply和call方法去实现。</p>
<h1 id="借用构造函数（类式继承）"><a href="#借用构造函数（类式继承）" class="headerlink" title="借用构造函数（类式继承）"></a>借用构造函数（类式继承）</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;借用构造函数（类式继承）&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        /*  
        在js中，被继承的函数称为超类型（父类，基类也行），继承的函数称为子类型（子类，派生类）。使用原型继承主要由两个问题：  
        一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。  

        伪类解决引用共享和超类型无法传参的问题，我们可以采用“借用构造函数”技术  
         */  
        function Parent(age){  
            this.colors=[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];  
            this.age=age;  
        }  
        function Child(age){  
            Parent.call(this,age);  
        }  
        var child=new Child(&quot;lisi&quot;);  
        var child2=new Child(&quot;zhangsan&quot;);  
        var obj=new Parent(&quot;wangwu&quot;);  
        console.log(child.age);//lisi  
        console.log(child.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]  
        child.colors.push(&quot;yellow&quot;);  
         console.log(child.colors);// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]  
            console.log(obj.colors);// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]  
        console.log(child2.colors);//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]  
        /*  
        借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承  
         */  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><pre><code>  &lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型继承&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        //原型式继承是借助已有的对象创建新的对象，将子类的原型指向父类，就相当于加入了父类这条原型链  
        //为了让子类继承父类的属性（也包括方法），首先需要定义一个构造函数。然后，将父类的新实例赋值给子类构造函数的原型。代码如下：  
        function Parent(){  
            this.age=12;  
        }  
        function Child(){  
            this.name=&quot;lisi&quot;;  
        }  
        Child.prototype=new Parent();//Child继承Parent，通过原型，形成链条  
        var test=new Child();  
        console.log(test.name);//lisi  
        console.log(test.age);//12  得到被继承的属性  
        //继续原型链继承  
        function Brother(){  
            this.job=&quot;worker&quot;;  
        }  
        Brother.prototype=new Child();//继续原型链继承  
        var person=new Brother();  
        person.name=&quot;wangwu&quot;;  
        console.log(person.name);//wangwu  实例属性覆盖原型属性  
        console.log(person.age);//12  继承了Parent和Child,弹出12和lisi  
        console.log(person.job);//worker  

        //以上原型链继承还缺少一环，那就是Object，所有的构造函数都继承自Object。而继承Object是自动完成的，并不需要我们自己手动继承  

        //确定原型和实例的关系  
        //可以通过两种方式来确定原型和实例之间的关系。操作符instanceof和isPrototypeof()方法：  
        console.log(person instanceof Brother);//true  
        console.log(person instanceof Child);//true  
        console.log(person instanceof Parent);//true  
        console.log(Brother.prototype.isPrototypeOf(person));//true  
        console.log(Child.prototype.isPrototypeOf(Brother.prototype));//true  
        console.log(Child.prototype.isPrototypeOf(test));//true  
        console.log(Parent.prototype.isPrototypeOf(Child.prototype));//true  
        //只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型，因此，isPrototypeof()方法也会返回true  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>Child.prototype=new Parent();这一行相当于完全删除了Child的prototype 对象原先的值，然后赋予一个新值。</p>
<p>这样赋值之后，需要重新指定：Child.prototype.constructor = Child;</p>
<p>因为任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Child.prototype=new Parent();”这一行，Child.prototype.constructor是指向Child的；加了这一行以后，Child.prototype.constructor指向Parent。所以为了确保Child.prototype.constructor是指向Child，需要重新指定Child.prototype.constructor = Child;</p>
<p>更重要的是：每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。</p>
<pre><code>console.log(child.constructor == Child.prototype.constructor);//true  



&lt;script type=&quot;text/javascript&quot;&gt;  
    function Parent(name){  
        this.name = name;  
    }  
    function Child(age){  
        this.age = age;  
    }  
    Child.prototype = new Parent();  
    var child = new Child(&quot;lisi&quot;,23);  
    console.log(child.constructor == Child.prototype.constructor);//false  
    console.log(child.constructor == Parent);//true  
    &lt;/script&gt;  
</code></pre><p>但是，在运行”Child.prototype = new Parent();”这一行之后，Child.constructor也指向Parent！</p>
<pre><code>&lt;pre name=&quot;code&quot; class=&quot;javascript&quot;&gt;console.log(child.constructor == Parent);//true  
</code></pre><p>这显然会导致继承链的紊乱（child明明是用构造函数Child生成的），因此我们必须手动纠正，将Child.prototype对象的constructor值改为Child。这就是需要重新指定：Child.prototype.constructor = Child;的意义所在。</p>
<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，
　　</p>
<pre><code>o.prototype = {};  
</code></pre><p>那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</p>
<pre><code>o.prototype.constructor = o;  
</code></pre><p>直接继承prototype</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
//由于Parent对象中，不变的属性都可以直接写入Parent.prototype。所以，我们也可以让Child()跳过 Parent()，直接继承Parent.prototype。  
    function Parent(name){  
        this.name = name;  
    }  
    function Child(age){  
        this.age = age;  
    }  
    //将Child的prototype对象，然后指向Parent的prototype对象，这样就完成了继承  
    Child.prototype = Parent.prototype;  
    Child.prototype.constructor = Child;//这里同样会修改Parent的构造函数  
    var child = new Child(&quot;lisi&quot;,23);  
    console.log(Child.prototype.constructor);//Child  
    console.log(Parent.prototype.constructor);//Child  
    /* 
    与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Parent的实例了），比较省内存。缺点是 Child.prototype和Parent.prototype现在指向了同一个对象，那么任何对Child.prototype的修改，都会反映到Parent.prototype。 
     */  
&lt;/script&gt;  
</code></pre><h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p>原型式继承，要求必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给obj函数，然后再根据具体要求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是box对象，我们将其传入obj()函数，然后该函数就会返回一个新对象。这个新对象将box作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。也就说box.family不仅属于box所有，而且也会被a1和a2共享。这就相当于又创建了box对象的两个副本(即对box对象进行了浅复制)。</p>
<p>这种继承方式的缺点是：包含引用类型值的属性始终都会共享相应的值。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型式继承&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        //这种继承借助原型并基于已有的对象创建新对象，同时还不用创建自定义类型的方式称为原型式继承  
        //原型式继承首先在obj()函数内部创建一个临时性的构造函数 ，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。  
        function obj(o){  
            function F(){}  
            F.prototype=o;  
            return new F();  
        }  
        var box={  
            name:&quot;lisi&quot;,  
            family:[&apos;brother&apos;,&apos;sister&apos;,&apos;me&apos;]//包含引用类型值的属性始终都会共享相应的值  
        };  
        var a1=obj(box);  
        console.log(a1.name);//lisi  
        a1.name=&quot;wangwu&quot;;  
        console.log(a1.name);//wangwu  
        console.log(a1.family);// [&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;]  
        a1.family.push(&quot;mother&quot;);  
        console.log(a1.family);// [&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;, &quot;mother&quot;]  

        var a2=obj(box);  
        console.log(a2.name);//lisi  
        console.log(a2.family);// [&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;, &quot;mother&quot;]  
        console.log(box.family);//[&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;, &quot;mother&quot;]  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>Object.create()原型式继承</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    //ECMAScript5新增了Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和可选参数--一个为新对象定义额外属性的对象。  
        var box = {  
            name:&quot;lisi&quot;,  
            family:[&apos;brother&apos;,&apos;sister&apos;,&apos;me&apos;]//包含引用类型值的属性始终都会共享相应的值  
        };  
        var a1 = Object.create(box);  
        console.log(a1.name);//lisi  
        a1.name = &quot;wangwu&quot;;  
        console.log(a1.name);//wangwu  
        console.log(a1.family);// [&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;]  
        a1.family.push(&quot;mother&quot;);  
        console.log(a1.family);// [&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;, &quot;mother&quot;]  

        /* 
        Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 
         */  
        var a2 = Object.create(box,{  
            name:{  
                //描述符对象  
                value:&quot;赵六&quot;  
            }  
        });  
        console.log(a2.name);//赵六  覆盖了原型上的name属性  
        a2.family.push(&quot;child&quot;);  
        console.log(a2.family);// [&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;, &quot;mother&quot;, &quot;child&quot;]  
        console.log(box.family);//[&quot;brother&quot;, &quot;sister&quot;, &quot;me&quot;, &quot;mother&quot;, &quot;child&quot;]  
    &lt;/script&gt;  
</code></pre><h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p> 组合式继承是比较常用的一种继承方法，其背后的思路是：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;组合继承&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function Parent(age){  
            this.colors=[&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];  
            this.age=age;  
        }  
        Parent.prototype.run=function(){  
            console.log(this.colors+&apos;---&apos;+this.age);  
        }  
        function Child(age){  
            Parent.call(this,age)//继承属性  对象冒充，给超类型传参  
        }  
        Child.prototype=new Parent();//原型链继承,继承原型方法  
        var child=new Child(&quot;lisi&quot;);  
        child.run();//red,blue,green---lisi  
        /*  
        call()的用法：改变this指向。  
         */  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>这种继承方式是把原型式+工厂模式结合起来，目的是为了封装创建的过程。</p>
<p>根据已有对象person，利用原型式继承返回一个新的对象，并根据要求对该对象进行增强。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;寄生式继承&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        //这种继承方式是把原型式+工厂模式结合起来，目的是为了封装创建的过程。  
         function obj(o){  
            function F(){}  
            F.prototype=o;  
            return new F();  
        }  
        function createAnother(original){//工厂模式  
            var clone=obj(original);//通过调用obj函数创建一个新对象  
            clone.sayHi=function(){//根据要求增强新对象  
                console.log(&quot;Hi&quot;);  
            };  
            return clone;  
        }  
        var person={  
            name:&apos;liujie&apos;,  
            family:[&quot;father&quot;,&quot;mother&quot;,&quot;sister&quot;]  
        };  
        var anotherPerson=createAnother(person);  
        //anotherPerson是返回的新对象，不仅具有person的属性和方法，还有自己的sayHi方法  
        anotherPerson.sayHi();//Hi  
        console.log(anotherPerson.name);//liujie  
        console.log(anotherPerson.family);// [&quot;father&quot;, &quot;mother&quot;, &quot;sister&quot;]  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>组合式继承的小问题</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;组合式继承的小问题&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        //组合式继承是js最常用的继承模式，但组合继承的超类型在使用过程中会被调用两次；一次是创建子类型原型的时候，另一次是在子类型构造函数的内部  
        //子类型最终会包含超类型对象的全部实例属性  
        function SuperType(name){  
            this.name=name;  
            this.color=[&apos;red&apos;,&apos;blue&apos;,&apos;yellow&apos;];  
        }  
        SuperType.prototype.sayName=function(){  
            console.log(this.name);  
        };  
        function SubType(name,age){  
            SuperType.call(this,name);//第二次调用SuperType()  
            this.age=age;  
        }  
        SubType.prototype=new SuperType();//第一次调用SuperType()  
        console.log(SubType.prototype.constructor);//SuperType(name)  
        SubType.prototype.constructor=SubType;//这里如果不设置SubType.prototype.constructor将指向SuperType()  因为上面实现继承的同时也重写了SubType.prototype  
        SubType.prototype.sayAge=function(){  
            console.log(this.age);  
        };  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><p>这种方式的目的就在于：解决组合继承中父类构造函数调用两次造成的子类原型上创建多余的、不必要的属性的问题。<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br> 基本思路是：不必为指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。我们可以使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。这样就可以避免两次调用父类的构造函数，不会在子类原型上创建多余的、不必要的属性。</p>
<pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;寄生组合式继承&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function object(o){//o=SuperType.prototype  
            function F(){}  
            F.prototype = o;//F.prototype=SuperType.prototype  
            return new F();//这里返回父类原型的副本  
        }  
        function inheritPrototype(subType, superType){  
            var prototype = object(superType.prototype);   //创建对象   其实就是超类型原型的一个副本  
            //console.log(prototype);// SuperType { sayName=function()}  
            //console.log(prototype.constructor);//SuperType(name)  
            prototype.constructor = subType;  //增强对象   为创建的副本添加constructor 属性，从而弥补下一步重写子类原型而让子类失去默认的constructor 属性  
            subType.prototype = prototype;   //指定对象  将超类型原型的副本赋值给子类原型  这样就实现了继承  
            //console.log(subType.prototype.constructor);//SubType(name, age)  
        }  

        function SuperType(name){  
            this.name = name;  
            this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  
        }  

        SuperType.prototype.sayName = function(){  
            alert(this.name);  
        };  

        function SubType(name, age){  
            SuperType.call(this, name);//继承属性  
            this.age = age;  
        }  

        inheritPrototype(SubType, SuperType);//通过这里实现继承  

        SubType.prototype.sayAge = function(){//子类的原型方法  
            alert(this.age);  
        };  

        var instance1 = new SubType(&quot;Nicholas&quot;, 29);  
        instance1.colors.push(&quot;black&quot;);  
        alert(instance1.colors);  //&quot;red,blue,green,black&quot;  
        instance1.sayName();      //&quot;Nicholas&quot;;  
        instance1.sayAge();       //29  


        var instance2 = new SubType(&quot;Greg&quot;, 27);  
        alert(instance2.colors);  //&quot;red,blue,green&quot;   引用问题解决  
        instance2.sayName();      //&quot;Greg&quot;;  
        instance2.sayAge();       //27  

    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h2 id="js继承方式及其优缺点"><a href="#js继承方式及其优缺点" class="headerlink" title="js继承方式及其优缺点"></a>js继承方式及其优缺点</h2><p>原型链继承的缺点</p>
<p>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p>
<p>借用构造函数（类式继承）</p>
<p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</p>
<p>组合式继承</p>
<p>组合式继承是比较常用的一种继承方法，其背后的思路是：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<p>组合继承缺点：组合继承最大的问题：就是无论什么情况下，都会调用两次超类型构造函数。一次是在创建子类原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。这样就会导致在子类原型上创建不必要的、多余的属性。<br>非构造函数的继承</p>
<h2 id="浅拷贝继承"><a href="#浅拷贝继承" class="headerlink" title="浅拷贝继承"></a>浅拷贝继承</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
//把父对象的属性，全部拷贝给子对象，也能实现继承  
var Parent = {  
    name:&quot;lisi&quot;,  
    friends:[&apos;wangwu&apos;,&apos;zhaoliu&apos;]  
};  
function extendCopy(p){  
    var c = {};  
    for(var i in p){  
        c[i] = p[i];  
    }  
    return c;  
}  
var Child = extendCopy(Parent);  
Child.age = 23;  
Child.friends.push(&quot;zhangsan&quot;);  
console.log(Child.name);//lisi  
console.log(Child.friends);//[&quot;wangwu&quot;, &quot;zhaoliu&quot;, &quot;zhangsan&quot;]  
console.log(Parent.friends);//[&quot;wangwu&quot;, &quot;zhaoliu&quot;, &quot;zhangsan&quot;]  
//缺点：这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。上例中父对象的friends属性就被修改了。  
//所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做&quot;浅拷贝&quot;。这是早期jQuery实现继承的方式。  
&lt;/script&gt;  
</code></pre><h2 id="深拷贝继承"><a href="#深拷贝继承" class="headerlink" title="深拷贝继承"></a>深拷贝继承</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
//所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。  
var Parent = {  
    name:&quot;lisi&quot;,  
    friends:[&apos;wangwu&apos;,&apos;zhaoliu&apos;]  
};  
function deepCopy(p,c){  
    var c = c || {};  
    for(var i in p){  
        //如果父元素的属性是对象类型并且是数组，则递归拷贝  
        if(typeof p[i] === &apos;object&apos;){  
            c[i] = (p[i].constructor === Array) ? [] : {};  
            deepCopy(p[i],c[i]);  
        }else{//如果是基本类型，则直接拷贝  
            c[i] = p[i];  
        }  
    }  
    return c;  
}  
var Child = deepCopy(Parent);  
Child.friends.push(&quot;zhangsan&quot;);  
console.log(Child.friends);//[&quot;wangwu&quot;, &quot;zhaoliu&quot;, &quot;zhangsan&quot;]  
console.log(Parent.friends);//[&quot;wangwu&quot;, &quot;zhaoliu&quot;]  
//jQuery库使用的就是这种继承方法  
&lt;/script&gt;  
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/01/js对象/" class="article-date">
  	<time datetime="2016-04-01T05:14:18.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/01/js对象/">js对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;工厂模式&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
 function createPerson(name,age,job){  
        var o=new Object();  
        o.name=name;  
        o.age=age;  
        o.job=job;  
        o.sayName=function(){  
                console.log(this.name);  
        };  
        return o;  
    }  
    var person1=createPerson(&quot;liujie&quot;,13,&quot;student&quot;);  
    var person2=createPerson(&quot;lisi&quot;,14,&quot;doctor&quot;);  
    person1.sayName();  
    person2.sayName();  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>可以无数次的调用这个函数，每次它都会返回一个包含3个属性和一个方法的对象。 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题即怎样知道一个对象的类型。</p>
<h1 id="二、构造函数模式"><a href="#二、构造函数模式" class="headerlink" title="二、构造函数模式"></a>二、构造函数模式</h1><p> 构造函数模式与工厂模式区别：<br>    1、没有显示地创建对象<br>    2、直接将属性和方法赋给了this对象<br>    3、没有return语句</p>
<p> 特别注意：构造函数始终都应该以一个大写字母开头，非构造函数应该以小写字母开头<br>构造函数本身也是函数，只不过用来创建对象而已</p>
<pre><code> &lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;构造函数模式&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    function Person(name,age,job){  
        /*  
        要创建Person的新实例，必须使用new操作符  
        1、创建一个新对象  
        2、将构造函数的作用域赋值给新对象(因此this就指向了这个新对象)  
        3、执行这个构造函数中的代码，为这个新对象添加属性  
        4、返回新对象  
         */  
        this.name=name;  
        this.age=age;  
        this.job=job;  
        this.sayName=function(){  
            console.log(this.name);  
        };  
    }  
    var person1=new Person(&quot;liujie&quot;,13,&quot;student&quot;);  
    var person2=new Person(&quot;lisi&quot;,15,&quot;doctor&quot;);  
    person2.sayName();  
    person1.sayName();  
    //constructor属性指向构造函数  
    console.log(person1.constructor==Person);//true  
    console.log(person2.constructor==Person);//true  
    //创建的所有对象既是Object的实例，也是Person的实例  
    //之所以是Object的实例，是因为所有对象均继承自Object  
    console.log(person1 instanceof Object);//true  
    console.log(person1 instanceof Person);//true  
    console.log(person2 instanceof Object);//true  
    console.log(person2 instanceof Person);//true  

    //构造函数问题：每个方法都要在每个实例上重新创建一遍。每个Person实例都有一个不同的Function实例  
    console.log(person1.sayName==person2.sayName);//false  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  




&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;构造函数模式2&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    function Person(name,age,job){  
        this.name=name;  
        this.age=age;  
        this.job=job;  
        this.sayName=function(){  
            console.log(this.name);  
        };  
    }  
    //当作构造函数使用  
    var person=new Person(&quot;liujie&quot;,14,&quot;student&quot;);  
    person.sayName();//liujie  
    //当作普通函数调用  
    Person(&quot;lisi&quot;,16,&quot;doctor&quot;);  
    window.sayName();//lis  
    //在另一个对象的作用域中调用  
    var o=new Object();  
    Person.call(o,&quot;wangwu&quot;,15,&quot;master&quot;);//这里是在对象o的作用域中调用Person构造函数，调用后o就拥有了所有属性和sayName()方法  
    o.sayName();//wangwu  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h1><p>prototype就是原型对象<br>    使用原型对象的好处就是让所有实例共享它所包含的属性和方法<br>    每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<pre><code>所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。
这里Person.prototype.constructor指向Person

当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。换句话说，这个指针与构造函数没有关系。

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。
搜索首先从实例本身开始。如果实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有指定名字的属性。



&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型模式&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    function Person(){  
    }  
    Person.prototype.name=&quot;liujie&quot;;  
    Person.prototype.age=13;  
    Person.prototype.job=&quot;student&quot;;  
    Person.prototype.sayName=function(){  
        console.log(this.name);  

    };  
    //这里person1和person2访问的是同一组属性和同一个sayName()方法  
    var person1=new Person();  
    person1.sayName();//liujie  
    var person2=new Person();  
    person2.sayName();//liujie  
    console.log(person1.sayName==person2.sayName);//true  

    console.log(Person.prototype.isPrototypeOf(person1));//true  
    console.log(Person.prototype.isPrototypeOf(person2));//true  

    //Object.getPrototypeOf()返回的对象就是原型对象  
    console.log(Object.getPrototypeOf(person1)==Person.prototype);//true  
    console.log(Object.getPrototypeOf(person2)==Person.prototype);//true  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  




&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型模式2&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function Person(){  
    }  
    Person.prototype.name=&quot;liujie&quot;;  
    Person.prototype.age=13;  
    Person.prototype.job=&quot;student&quot;;  
    Person.prototype.sayName=function(){  
        console.log(this.name);  

    };  
    //这里person1和person2访问的是同一组属性和同一个sayName()方法  
    var person1=new Person();  
    person1.name=&quot;liujiejie&quot;;  
    //这里说明了可以通过对象实例访问保存在原型中的值，但是不能通过对象实例重写原型中的值  
    //如果对象实例中的属性与实例原型中的一个属性同名，实例中的属性会屏蔽原型中的那个属性  
    //person1.name=null;//即使将这个属性设置为null,也只会在实例中设置这个属性，而不会恢复其指向原型的链接  
    delete person1.name;//如果使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性  
    person1.sayName();//liujiejie  
    var person2=new Person();  
    person2.sayName();//liujie  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  




&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型模式3&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function Person(){  
    }  
    Person.prototype.name=&quot;liujie&quot;;  
    Person.prototype.age=13;  
    Person.prototype.job=&quot;student&quot;;  
    Person.prototype.sayName=function(){  
        console.log(this.name);  

    };  
    //这里person1和person2访问的是同一组属性和同一个sayName()方法  
    //使用hasOwnProperty()方法，当给定属性存在于实例中时，返回true  
    var person1=new Person();  
    var person2=new Person();  
    console.log(person1.hasOwnProperty(&quot;name&quot;));//false  
    person1.name=&quot;liujiejie&quot;;  
    console.log(person1.name);//liujiejie   来自实例  
    console.log(person1.hasOwnProperty(&quot;name&quot;));//true  
    console.log(person2.name);//liujie  来自原型  
    console.log(person2.hasOwnProperty(&quot;name&quot;));//false  
    delete person1.name;  
    console.log(person1.name);//liujie 来自原型  
    console.log(person1.hasOwnProperty(&quot;name&quot;));  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="四、原型的动态性"><a href="#四、原型的动态性" class="headerlink" title="四、原型的动态性"></a>四、原型的动态性</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型的动态性&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function Person(){  
        }  
        Person.prototype = {  
            constructor: Person,  
            name : &quot;Nicholas&quot;,  
            age : 29,  
            job : &quot;Software Engineer&quot;,  
            sayName : function () {  
                alert(this.name);  
            }  
        };  
        var friend = new Person();//即使先创建了实例，后修改了原型也没有问题  
        Person.prototype.sayHi = function(){//向原型中添加方法  
            alert(&quot;hi&quot;);  
        };  
        friend.sayHi();   //&quot;hi&quot; – works! 先在实例中搜索sayHi方法，找不到的话再搜索原型  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  




&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型的动态性2&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
        function Person(){  
        }  

        var friend = new Person();//调用构造函数创建实例，并向实例中添加一个指向最初原型的[[Prototype]]指针，而把原型重写修改后就等于切断了构造函数与最初原型之间的联系。  
        Person.prototype = {  
            //这里重写原型对象切断了现有的原型与任何之前已经存在的对象实例之间的联系，之前的实例引用的仍然是最初的原型  
            constructor: Person,  
            name : &quot;Nicholas&quot;,  
            age : 29,  
            job : &quot;Software Engineer&quot;,  
            sayName : function () {  
                alert(this.name);  
            }  
        };  
        friend.sayName();   //error  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><h1 id="五、原型与in操作符"><a href="#五、原型与in操作符" class="headerlink" title="五、原型与in操作符"></a>五、原型与in操作符</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;原型与in操作符&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    /*  
    只要能够访问到给定属性，in操作符就返回true。不管属性存在于原型上还是实例上。  
     */  
        function Person(){  
    }  
    Person.prototype.name=&quot;liujie&quot;;  
    Person.prototype.age=13;  
    Person.prototype.job=&quot;student&quot;;  
    Person.prototype.sayName=function(){  
        console.log(this.name);  

    };  
    //这里person1和person2访问的是同一组属性和同一个sayName()方法  
    //使用hasOwnProperty()方法，当给定属性存在于实例中时，返回true  
    var person1=new Person();  
    var person2=new Person();  
    console.log(person1.hasOwnProperty(&quot;name&quot;));//false  
    console.log(&quot;name&quot; in person1);//true  

    person1.name=&quot;liujiejie&quot;;  
    console.log(person1.name);//liujiejie   来自实例  
    console.log(person1.hasOwnProperty(&quot;name&quot;));//true  
    console.log(&quot;name&quot; in person1);//true  

    console.log(person2.name);//liujie  来自原型  
    console.log(person2.hasOwnProperty(&quot;name&quot;));//false  
    console.log(&quot;name&quot; in person2);//true  

    delete person1.name;  
    console.log(person1.name);//liujie   来自原型  
    console.log(person1.hasOwnProperty(&quot;name&quot;));//false  
    console.log(&quot;name&quot; in person1);//true  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会存在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的，但是在IE8及更早版本中例外。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    var obj = {  
        toString : function(){  
            return &quot;myvalue&quot;;  
        }  
    }  
    for(var prop in obj){  
        if(prop == &quot;toString&quot;){  
            alert(&quot;toString found&quot;);  
        }  
    }  
    &lt;/script&gt;  
</code></pre><p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    function Person(){}  
    Person.prototype.name = &quot;lisi&quot;;  
    Person.prototype.age = 23;  
    Person.prototype.sayName = function(){  
        alert(this.name+&quot;--&quot;+this.age);  
    }  
    var keys = Object.keys(Person.prototype);  
    console.log(keys);//[&quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;]  
    var person1 = new Person();  
    person1.name = &quot;wangwu&quot;;  
    person1.age = 23;  
    console.log(Object.keys(person1));//[&quot;name&quot;, &quot;age&quot;]  
    &lt;/script&gt;  
</code></pre><p>如果想要得到所有的实例属性，无论它是否可枚举，可以使用Object.getOwnPropertyNames()方法</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    function Person(){}  
    Person.prototype.name = &quot;lisi&quot;;  
    Person.prototype.age = 23;  
    Person.prototype.sayName = function(){  
        alert(this.name+&quot;--&quot;+this.age);  
    }  
    var keys2 = Object.getOwnPropertyNames(Person.prototype);  
    console.log(keys2);//[&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;]  
    &lt;/script&gt;  
</code></pre><p>注意：这里的结果中包含了不可枚举的constructor属性。Object.getOwnPropertyNames()和Object.keys()方法都可以用来代替for-in循环</p>
<h1 id="六、简单的原型语法"><a href="#六、简单的原型语法" class="headerlink" title="六、简单的原型语法"></a>六、简单的原型语法</h1><pre><code>&lt;!DOCTYPE html&gt;  
&lt;html lang=&quot;en&quot;&gt;  
    &lt;head&gt;  
        &lt;meta charset=&quot;utf-8&quot;&gt;  
        &lt;title&gt;更简单的原型语法&lt;/title&gt;  
    &lt;/head&gt;  
    &lt;body&gt;  
    &lt;script type=&quot;text/javascript&quot;&gt;  
    /*  
    这里将Person.prototype设置为等于一个对象字面量形式创建的新对象，最终结果相同  
    但是有一个例外：constructor属性不再指向Person了  
    因为，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性  

    而我们在这里本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性(指向Object构造函数)，不再指向Person函数。  
     */  
        function Person(){  
        }  
        Person.prototype = {  
            //constructor:Person,//显式地设置构造函数为Person  
            //这样重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的。因此，  
            考虑使用Object.defineProperty()方法。  
            name : &quot;Nicholas&quot;,  
            age : 29,  
            job: &quot;Software Engineer&quot;,  
            sayName : function () {  
                alert(this.name);  
            }  
        };  

        var friend = new Person();  

        alert(friend instanceof Object);  //true  
        alert(friend instanceof Person);  //true  
        alert(friend.constructor == Person);  //false  
        alert(friend.constructor == Object);  //true  
    &lt;/script&gt;  
    &lt;/body&gt;  
&lt;/html&gt;  
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js中的定位" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/13/js中的定位/" class="article-date">
  	<time datetime="2016-03-13T08:58:19.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/js中的定位/">js中的定位</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li>clientHeight和clientWidth用于描述元素内尺寸，是指元素内容+内边距 大小，不包括边框（IE下实际包括）、外边距、滚动条部分</li>
<li>offsetHeight和offsetWidth用于描述元素外尺寸，是指 元素内容+内边距+边框，不包括外边距和滚动条部分</li>
<li>clientTop和clientLeft返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度</li>
<li>offsetTop和offsetLeft表示该元素的左上角（边框外边缘）与已定位的父容器（offsetParent对象）左上角的距离</li>
<li>offsetParent对象是指元素最近的定位（relative,absolute）祖先元素，递归上溯，如果没有祖先元素是定位的话，会返回null</li>
</ul>
<h3 id="视口大小"><a href="#视口大小" class="headerlink" title="视口大小"></a>视口大小</h3><p>客户区大小：元素内容及其内边距所占据的空间大小<br><img src="http://i260.photobucket.com/albums/ii7/ruanyf/blog/bg2009091402.gif" alt="enter image description here"><br>document元素的clientHeight和clientWidth属性，就代表了视口的大小。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　　　width: <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">　　　　　　　　height: <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　　　width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">　　　　　　　　height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的getViewport函数就可以返回浏览器窗口的高和宽。使用的时候，有三个地方需要注意：</p>
<ul>
<li>这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。；</li>
<li>大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。</li>
<li>clientWidth和clientHeight都是只读属性，不能对它们赋值<h3 id="包含滚动"><a href="#包含滚动" class="headerlink" title="包含滚动"></a>包含滚动</h3>滚动大小：包含滚动内容的元素的大小。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPagearea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　　　width: <span class="built_in">document</span>.body.scrollWidth,</span><br><span class="line">　　　　　　　　height: <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　　　width: <span class="built_in">document</span>.documentElement.scrollWidth,</span><br><span class="line">　　　　　　　　height: <span class="built_in">document</span>.documentElement.scrollHeight</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但这个函数有一个问题。如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对getPagearea()函数进行改写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPagearea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　　　width: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollWidth,</span><br><span class="line">　　　　　　　　　　　　　　　　<span class="built_in">document</span>.body.clientWidth),</span><br><span class="line">　　　　　　　　height: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight,</span><br><span class="line">　　　　　　　　　　　　　　　　<span class="built_in">document</span>.body.clientHeight)</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　width: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollWidth,</span><br><span class="line">　　　　　　　　　　　　　　<span class="built_in">document</span>.documentElement.clientWidth),</span><br><span class="line">　　　　　height: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight,</span><br><span class="line">　　　　　　　　　　　　　　<span class="built_in">document</span>.documentElement.clientHeight)</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="绝对位置"><a href="#绝对位置" class="headerlink" title="绝对位置"></a>绝对位置</h3><p> 网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。首先，每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。<br> <img src="http://i260.photobucket.com/albums/ii7/ruanyf/blog/bg2009091403.gif" alt="enter image description here"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> actualLeft = element.offsetLeft;</span><br><span class="line">　　　　<span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line">　　　　<span class="keyword">while</span> (current !== <span class="literal">null</span>)&#123;</span><br><span class="line">　　　　　　actualLeft += current.offsetLeft;</span><br><span class="line">　　　　　　current = current.offsetParent;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> actualLeft;</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> actualTop = element.offsetTop;</span><br><span class="line">　　　　<span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line">　　　　<span class="keyword">while</span> (current !== <span class="literal">null</span>)&#123;</span><br><span class="line">　　　　　　actualTop += current.offsetTop;</span><br><span class="line">　　　　　　current = current.offsetParent;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> actualTop;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="相对位置"><a href="#相对位置" class="headerlink" title="相对位置"></a>相对位置</h3><p>网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。<br>有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。<br><img src="http://i260.photobucket.com/albums/ii7/ruanyf/blog/bg2009091404.gif" alt="enter image description here"><br>但是有一种简单方法getBoundingClientRect()：它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。<br>所以，网页元素的相对位置就是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">this</span>.getBoundingClientRect().left;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">this</span>.getBoundingClientRect().top;</span><br></pre></td></tr></table></figure></p>
<p>再加上滚动距离，就可以得到绝对位置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">varX=<span class="keyword">this</span>.getBoundingClientRect().left+<span class="built_in">Math</span>.max(<span class="built_in">document</span>.</span><br><span class="line">      documentElement.scrollLeft, <span class="built_in">document</span>.body.scrollLeft);</span><br><span class="line">varY=<span class="keyword">this</span>.getBoundingClientRect().top+<span class="built_in">Math</span>.max(<span class="built_in">document</span>.</span><br><span class="line">       documentElement.scrollTop,<span class="built_in">document</span>.body.scrollTop);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考资料：<br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html</a><br><a href="http://www.cnblogs.com/dolphinX/archive/2012/11/19/2777756.html" target="_blank" rel="external">http://www.cnblogs.com/dolphinX/archive/2012/11/19/2777756.html</a><br><a href="http://www.cnblogs.com/myzhibie/p/4256164.html?utm_source=tuicool" target="_blank" rel="external">http://www.cnblogs.com/myzhibie/p/4256164.html?utm_source=tuicool</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-负margin" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/12/负margin/" class="article-date">
  	<time datetime="2016-03-12T10:38:53.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/负margin/">神奇的负margin</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在理解负margin的神奇作用之前，我们首先要了解的事情是margin的参考线，在此基础上，margin在普通文档流<br>或者与浮动结合或者与绝对定位结合才能产生神奇的作用。</p>
<h2 id="1、margin的参考线"><a href="#1、margin的参考线" class="headerlink" title="1、margin的参考线"></a>1、margin的参考线</h2><p>  何谓参考线？参考线就是 margin 移动的基准点，此基准点相对于 box 是静止的。而 margin 的数值，就是 box 相对于参考线的位移量。</p>
<p>  在 margin 中 top、right、bottom、left 的参考线并不一致为一类</p>
<ul>
<li>top 以containing block 的 content 上边或者垂直上方相连元素 margin 的下边为参考线垂直向下位移；</li>
<li>left 以 containing block 的 content 左边或者水平左方相连元素 margin 的右边为参考线水平向右位移。</li>
<li>right 以元素本身的 border 右边为参考线水平向右位移；</li>
<li>bottom 以元素本身的border 下边为参考线垂直向下位移。</li>
</ul>
<p>总之， top 和 left 都是以外元素为参考，而 right 和 bottom以本元素为参考。上面的位移方向是指 margin 数值为正值时候的情形，如果是负值则位移方向相反。</p>
<h2 id="2、magin的大小"><a href="#2、magin的大小" class="headerlink" title="2、magin的大小"></a>2、magin的大小</h2><p><img src="http://www.planabc.net/wp-content/uploads/2008/02/margin_example.gif" alt="enter image description here"></p>
<ul>
<li>物理大小指的是除去 margin，也就是包含 border 以内的 box 大小</li>
<li>逻辑大小，则是 box 通过 margin 解析规则解析后得到的大小（这或许可以解释为什么IE5会错误解析盒模型）。</li>
<li><p>在上图中，box 的实际显示的宽度等于 box 的逻辑大小，而 box 实际显示的高度等于 box 的物理大小，这说明 box 实际显示的大小可能是 box 的逻辑大小，也可能是 box的 物理大小，规则到底是怎样的——</p>
<p><code>box 的实际大小 = box 的物理大小 + 正的 margin</code></p>
</li>
</ul>
<p>总之：box 最后的显示大小等于 box 的 border 及 border 内的大小加上正的 margin 值。而负的 margin 值不会影响 box 的实际大小，如果是负的 top 或 left 值会引起 box 的向上或向左位置移动，如果是 bottom 或 right 只会影响下面 box 的显示的参考线。</p>
<h2 id="3、margin的表现"><a href="#3、margin的表现" class="headerlink" title="3、margin的表现"></a>3、margin的表现</h2><h3 id="margin在普通文档流中的作用"><a href="#margin在普通文档流中的作用" class="headerlink" title="margin在普通文档流中的作用"></a>margin在普通文档流中的作用</h3><p>负边距对这些由文档流控制的元素的作用是，会使它们在文档流中的位置发生偏移，但这种偏移不同于相对定位，通过相对定位偏移后，其仍然会坚守着它原 来占据的空间，不会让文档流的其它元素乘虚而入。而通过负边距进行偏移的元素，它会放弃偏移前占据的空间，这样它后面文档流中的其它元素就会“流”过来填充这部分空间。<code>在普通文档流中，元素的最终边界是由margin决定的，margin为负的时候相当于元素的边界向里收。</code><br><img src="http://images.cnblogs.com/cnblogs_com/2050/201208/201208131525134914.png" alt="enter image description here"><br>负边距好像能减小元素在文档流中的尺寸一样，但事实上元素尺寸没有改变，只是文档流在计算元素位置时，会认为负边距把元素的尺寸减小了。<code>注意：文档流是从后面流向前面的，即文档流只能向左或者向上流动，不能向下或向右移动</code></p>
<h3 id="margin对浮动元素的影响"><a href="#margin对浮动元素的影响" class="headerlink" title="margin对浮动元素的影响"></a>margin对浮动元素的影响</h3><p>负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。</p>
<p>比如下图是三个向左浮动的元素，宽高都是100px：<br><img src="http://images.cnblogs.com/cnblogs_com/2050/201208/201208131525242264.png" alt="enter image description here"><br>都设一个margin-right:-50px<br><img src="http://images.cnblogs.com/cnblogs_com/2050/201208/201208131525274508.png" alt="enter image description here"><br>我们把浏览器缩小了，然后因为宽度不够，元素3掉下来了<br><img src="http://images.cnblogs.com/cnblogs_com/2050/201208/201208131525291213.png" alt="enter image description here"><br>我们给元素3设一个margin-left:-80px<br><img src="http://images.cnblogs.com/cnblogs_com/2050/201208/201208131525356191.png" alt="enter image description here"><br>这时我们看到元素3上去了，而且还覆盖了元素2的一部分。继续元素3设为margin-left:-100px<br><img src="http://images.cnblogs.com/cnblogs_com/2050/201208/20120813152537420.png" alt="enter image description here"></p>
<h3 id="负margin对绝对定位的影响"><a href="#负margin对绝对定位的影响" class="headerlink" title="负margin对绝对定位的影响"></a>负margin对绝对定位的影响</h3><p>绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就 是margin定义的边界，所以，如果margin为正的时候，那它的边界是向外扩的，<code>如果margin为负的时候，则它的边界是向里收的</code></p>
<h2 id="4、负margin的妙用"><a href="#4、负margin的妙用" class="headerlink" title="4、负margin的妙用"></a>4、负margin的妙用</h2><ul>
<li>双飞翼布局<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"page"</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"hd"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"bd"</span>&gt;</span>        </span><br><span class="line">                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"main"</span>&gt;</span>                  </span><br><span class="line">                    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"inner"</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">div</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"sub"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>       </span><br><span class="line">                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"extra"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">div</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"ft"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.main</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#39c</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">300px</span></span></span>;&#125;</span></span><br><span class="line"><span class="class">.sub</span> <span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">480px</span></span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> -<span class="number">100%</span></span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#f60</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">300px</span></span></span>;&#125;</span>   </span><br><span class="line"><span class="class">.extra</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">190px</span></span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> -<span class="number">190px</span></span></span>; </span><br><span class="line">       <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#666</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">300px</span></span></span>;&#125;</span></span><br><span class="line"><span class="class">.inner</span><span class="rules">&#123;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span> <span class="number">190px</span> <span class="number">0</span> <span class="number">480px</span></span></span>;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>圣杯布局<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"page"</span>&gt;</span>              </span><br><span class="line">            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"hd"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>              </span><br><span class="line">         <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"bd"</span>&gt;</span>                   </span><br><span class="line">              <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"main"</span>&gt;</span>main<span class="tag">&lt;/<span class="title">div</span>&gt;</span>                </span><br><span class="line">              <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"sub"</span>&gt;</span>sub圣杯布局<span class="tag">&lt;/<span class="title">div</span>&gt;</span>                   </span><br><span class="line">              <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"extra"</span>&gt;</span>extra<span class="tag">&lt;/<span class="title">div</span>&gt;</span>       </span><br><span class="line">         <span class="tag">&lt;/<span class="title">div</span>&gt;</span>          </span><br><span class="line">         <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"ft"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.main</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100%</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#39c</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">300px</span></span></span></span>&#125;</span><br><span class="line"><span class="class">.sub</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">190px</span></span></span>;<span class="rule"><span class="attribute">margin-left</span>:<span class="value">-<span class="number">100%</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#f60</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">300px</span></span></span>;<span class="rule"><span class="attribute">position</span>:<span class="value">relative</span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value">-<span class="number">190px</span></span></span></span>&#125;</span><br><span class="line"><span class="class">.extra</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">230px</span></span></span>;<span class="rule"><span class="attribute">margin-left</span>:<span class="value">-<span class="number">230px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#666</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">300px</span></span></span>;<span class="rule"><span class="attribute">position</span>:<span class="value">relative</span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value">-<span class="number">230px</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#bd</span><span class="rules">&#123;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span> <span class="number">230px</span> <span class="number">0</span> <span class="number">190px</span></span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>水平垂直居中（负margin+定位）<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#test</span><span class="rules">&#123;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">200px</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">200px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#F60</span></span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">position</span>:<span class="value">absolute</span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">50%</span></span></span>;<span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">50%</span></span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">margin-left</span>:<span class="value">-<span class="number">100px</span></span></span>;<span class="rule"><span class="attribute">margin-top</span>:<span class="value">-<span class="number">100px</span></span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>去除列表右边框<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>子元素1<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>子元素2<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>子元素3<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>子元素4<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>子元素5<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>子元素6<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span>,<span class="tag">ul</span>,<span class="tag">li</span><span class="rules">&#123;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span></span></span></span>&#125;<span class="tag">ul</span>,<span class="tag">li</span><span class="rules">&#123;<span class="rule"><span class="attribute">list-style</span>:<span class="value">none</span></span></span>&#125;</span><br><span class="line"><span class="id">#test</span><span class="rules">&#123;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">320px</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">210px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#CCC</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#test</span> <span class="tag">ul</span><span class="rules">&#123;<span class="rule"><span class="attribute">margin-right</span>:<span class="value">-<span class="number">10px</span></span></span>;<span class="rule"><span class="attribute">zoom</span>:<span class="value"><span class="number">1</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#test</span> <span class="tag">ul</span> <span class="tag">li</span><span class="rules">&#123;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100px</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">100px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#F60</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">margin-right</span>:<span class="value"><span class="number">10px</span></span></span>;<span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"><span class="number">10px</span></span></span>;<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span></span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>去除列表最后一个li元素的border-bottom<br>列表中我们经常会添加border-bottom值，最后一个li的border-bottom往往会与外边框重合，视觉上不雅观，往往要移除。<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span>,<span class="tag">ul</span>,<span class="tag">li</span><span class="rules">&#123;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span></span></span></span>&#125;<span class="tag">ul</span>,<span class="tag">li</span><span class="rules">&#123;<span class="rule"><span class="attribute">liststyle</span>:<span class="value">none</span></span></span>&#125;</span><br><span class="line"><span class="id">#test</span><span class="rules">&#123;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">20px</span></span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">390px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#f4f8fc</span></span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">border-radius</span>:<span class="value"><span class="number">3px</span></span></span>;<span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">2px</span> solid <span class="hexcolor">#d7e2ec</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#test</span> <span class="tag">li</span><span class="rules">&#123;<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">25px</span></span></span>;<span class="rule"><span class="attribute">line-height</span>:<span class="value"><span class="number">25px</span></span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">5px</span></span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"><span class="number">1px</span> dotted <span class="hexcolor">#d5d5d5</span></span></span>;<span class="rule"><span class="attribute">margin-bottom</span>:<span class="value">-<span class="number">1px</span></span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多列等高布局<br>此例关键是给每个框设置大的底部内边距，然后用数值相似的负外边距消除这个高度。这会导致每一列溢出容器元素，如果把外包容器的overflow属性设为hidden，列就在最高点被裁切。<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"left"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">style</span>=<span class="value">"height:50px"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">style</span>=<span class="value">"height:100px"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"right"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">style</span>=<span class="value">"height:200px"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span>,<span class="tag">p</span><span class="rules">&#123;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#wrap</span><span class="rules">&#123;<span class="rule"><span class="attribute">overflow</span>:<span class="value">hidden</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">580px</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span> auto</span></span></span>&#125;</span><br><span class="line"><span class="id">#left</span>,<span class="id">#center</span>,<span class="id">#right</span><span class="rules">&#123;<span class="rule"><span class="attribute">margin-bottom</span>:<span class="value">-<span class="number">200px</span></span></span>;<span class="rule"><span class="attribute">padding-bottom</span>:<span class="value"><span class="number">200px</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#left</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">140px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#777</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#center</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">300px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#888</span></span></span></span>&#125;</span><br><span class="line"><span class="id">#right</span><span class="rules">&#123;<span class="rule"><span class="attribute">float</span>:<span class="value">right</span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">140px</span></span></span>;<span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#999</span></span></span></span>&#125;</span><br><span class="line"><span class="tag">p</span><span class="rules">&#123;<span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#FFF</span></span></span>;<span class="rule"><span class="attribute">text-align</span>:<span class="value">center</span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<ul>
<li><a href="http://www.planabc.net/2007/03/18/css_attribute_margin/" target="_blank" rel="external">http://www.planabc.net/2007/03/18/css_attribute_margin/</a> </li>
<li><a href="http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html" target="_blank" rel="external">http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html</a></li>
<li><a href="http://segmentfault.com" target="_blank" rel="external">http://segmentfault.com</a></li>
<li><a href="http://www.cnblogs.com/jscode/archive/2012/08/28/2660078.html" target="_blank" rel="external">http://www.cnblogs.com/jscode/archive/2012/08/28/2660078.html</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css布局/">css布局</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 chandayang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>